<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PACMUSH ODYSSEY</title>
<style>
  :root { --bg:#0b0a0e; --card:#16131b; --pill:#1b141e; --line:#ffffff22; --shadow:#00000055; --text:#fff7ea; }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px}
  #hud{display:flex;gap:12px;align-items:center;user-select:none;font-weight:700;letter-spacing:.3px;flex-wrap:wrap;justify-content:center}
  .pill{padding:6px 10px;border-radius:999px;background:var(--pill);border:1px solid var(--line);box-shadow:0 3px 10px var(--shadow)}
  #legend{opacity:.9;font-size:14px}
  #game{display:block;width:1100px;max-width:95vw;height:auto;background:#0f0c14;border-radius:18px;border:2px solid #00000055;box-shadow:0 22px 70px #000000aa}
  .ov{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999}
  .card{max-width:1100px;width:92vw;background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 20px 80px #0009;padding:18px;max-height:88vh;overflow:auto}
  .title{font-weight:800;font-size:28px}
  .sub{opacity:.9}
  .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));margin-top:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badge{background:#ffffff10;border:1px solid var(--line);border-radius:999px;padding:2px 8px;font-size:12px}
  .btn{background:#0e0b13;border:1px solid var(--line);border-radius:10px;padding:10px 12px;font-weight:700;cursor:pointer;color:var(--text)}
  .btn[disabled]{opacity:.6;cursor:not-allowed}
  .sectionTitle{margin-top:14px;font-weight:800}
  .choice.disabled{opacity:.5;filter:grayscale(60%);pointer-events:none}
</style>
</head>
<body>
  <audio id="bgm" src="mushroom_hill_zone.mp3" loop></audio>
  <div id="wrap">
    <div id="hud">
      <div class="pill">Mode : <span id="mode">Solo</span></div>
      <div class="pill" id="leaderPill" style="display:none">Leader : <span id="leaderText" style="color:#ff4d4d;font-weight:800">—</span></div>
      <div class="pill">J1 — Score: <span id="score1">0</span> · Vies: <span id="lives1">3</span> · Pouvoir: <span id="power1">—</span></div>
      <div class="pill" id="p2hud" style="display:none">J2 — Score: <span id="score2">0</span> · Vies: <span id="lives2">3</span> · Pouvoir: <span id="power2">—</span></div>
      <div class="pill">Difficulté : <span id="diff">Guerre des Spores</span></div>
      <div id="legend" class="pill">J1: Flèches + Entrée · J2: ZQSD + F · P: pause/CR · O: menu</div>
    </div>
    <canvas id="game" width="1100" height="880" aria-label="PACMUSH ODYSSEY"></canvas>
  </div>

<script>
  // 🎵 Gestion musique
let bgm;

function initMusic() {
  bgm = document.getElementById("bgm");
  bgm.volume = 0.4; // volume de 0.0 (muet) à 1.0 (max)
}

function startMusic() {
  if (bgm) {
    bgm.play().catch(e => {
      console.log("Lecture auto bloquée par le navigateur :", e);
    });
  }
}

function stopMusic() {
  if (bgm) bgm.pause();
}

// Initialisation musique
initMusic();

// ⚠️ Les navigateurs bloquent la lecture automatique,
// on démarre la musique dès le 1er clic ou touche
document.addEventListener("keydown", startMusic, {once:true});
document.addEventListener("click", startMusic, {once:true});

/* =================== CODE COMPLET =================== */
/* ============ Réfs UI ============ */
const CANVAS = document.getElementById('game');
const CTX = CANVAS.getContext('2d');
const W = CANVAS.width, H = CANVAS.height;
const UI = {
  leaderPill: document.getElementById('leaderPill'),
  leaderText: document.getElementById('leaderText'),
  mode:document.getElementById('mode'),
  diff:document.getElementById('diff'),
  score1:document.getElementById('score1'),
  lives1:document.getElementById('lives1'),
  power1:document.getElementById('power1'),
  score2:document.getElementById('score2'),
  lives2:document.getElementById('lives2'),
  power2:document.getElementById('power2'),
  p2hud:document.getElementById('p2hud'),
  overlay:null, choices1:null, choices2:null, startBtn:null, modeSel:null
};

/* ============ Constantes ============ */
const TILE=28;
const COLS=Math.max(5,(W/TILE)|0);
const ROWS=Math.max(5,(H/TILE)|0);

/* Difficultés */
const DIFFICULTIES=[
  {id:'easy', name:'Cueillette du dimanche', label:'Cueillette du dimanche — facile', factor:0.25},
  {id:'medium', name:'Chiens Truffiers', label:'Chiens Truffiers — moyen', factor:0.5},
  {id:'hard', name:'Guerre des Spores', label:'Guerre des Spores — difficile', factor:1}
];
let SelectedDifficulty=DIFFICULTIES[2];

const MATCH_LEVELS_SOLO=1;
const MATCH_LEVELS_DUO=1;

// --- Semences aléatoires par session de jeu ---
let SESSION_SEEDS = [];
function reseedSession(levelCount){
  const n = Math.max(levelCount|0, 4);
  if (window.crypto && crypto.getRandomValues) {
    const arr = new Uint32Array(n);
    crypto.getRandomValues(arr);
    SESSION_SEEDS = Array.from(arr, v => (v>>>0) ^ (Date.now()>>>0) ^ ((Math.random()*1e9)|0));
  } else {
    SESSION_SEEDS = Array.from({length:n}, () => ((Date.now() + Math.random()*1e9)|0)>>>0);
  }
}


/* ============ Assets (sprites PNG fournis) ============ */
const SPRITES_BY_SPECIES = {
  cornucopioides: { game: 'champignon_6_bordered.png', ui: 'champignon_6_bordered.png' }, // Trompette de la mort
  muscaria:       { game: 'champignon_3.png',          ui: 'champignon_3.png' },          // Amanite tue-mouches
  cibarius:       { game: 'champignon_1.png',          ui: 'champignon_1.png' },          // Girolle
  edulis:         { game: 'champignon_4.png',          ui: 'champignon_4.png' },          // Cèpe
  morchella:      { game: 'champignon_5_bordered.png', ui: 'champignon_5_bordered.png' }, // Morille
  phalloides:     { game: 'champignon_2.png',          ui: 'champignon_2.png' },          // Amanite phalloïde
  stropharia:     { game: 'champignon_7.png',          ui: 'champignon_7.png' }, // Strophaire Vert-de-gris
  anthurus:       { game: 'champignon_8.png',          ui: 'champignon_8.png' }, // Anthurus d'archer
};

/* ============ Parasite sprites ============ */
const PARASITE_SPRITES = [
  null,
  'Parasite_1.png',
  'Parasite_2.png',
  'Parasite_3.png',
  'Parasite_4.png',
  'Parasite_5.png',
  'Parasite_6.png',
  'Parasite_7.png',
];
  

const _IMG_CACHE = new Map();
function loadImg(src){
  if(_IMG_CACHE.has(src)) return _IMG_CACHE.get(src);
  const i=new Image(); i.src=src; i.decoding='async'; i.loading='eager';
  _IMG_CACHE.set(src,i);
  return i;
}

function preloadCoreImages(){
  const list = [
    'sol_foret.png',
    TREE_PNG.chene, TREE_PNG.pin,
    ...Object.values(SPRITES_BY_SPECIES).flatMap(v => [v.game, v.ui]),
    ...PARASITE_SPRITES.slice(1)
  ];
  list.forEach(src => loadImg(src));
}

// --- ARBRES PNG (à la racine du projet, sinon ajuste les chemins) ---
const TREE_PNG = {
  chene: 'chene.png',
  pin:   'pin.png'
};

// Choix stable (même case -> même image) en fonction de la case et du niveau
function pickTreeSpriteAt(x, y){
  // hash simple et stable basé sur coord + index de niveau
  const h = (((x*73856093) ^ (y*19349663) ^ (LEVEL_INDEX*83492791)) >>> 0);
  return (h & 1) ? TREE_PNG.pin : TREE_PNG.chene;
}

  
function getSpritePath(speciesId, forUI=false){
  const rec = SPRITES_BY_SPECIES[speciesId];
  if(!rec) return null;
  return forUI ? rec.ui : rec.game;
}
function drawImgCenteredPath(path, x, y, s, ghost=false){
  if(!path) return;
  const img = loadImg(path);
  if(!img.complete) return;
  CTX.save();
  if(ghost) CTX.globalAlpha = 0.8;
  CTX.drawImage(img, x - s/2, y - s/2, s, s);
  CTX.restore();
}

/* ============ Entrées clavier ============ */
const Keys=Object.create(null);
function anyPanelOpen(){
  return (Game?.p1?.panelActive || Game?.p2?.panelActive) ? true : false;
}
addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();

  // Si un panneau est ouvert, on ne laisse PAS ce listener gérer ces touches
  if (anyPanelOpen() && ['arrowup','arrowdown','arrowleft','arrowright','enter','f','z','q','s','d'].includes(k)) {
    e.preventDefault();
    e.stopPropagation();
    return; // pas de Keys[k]=true ici !
  }

  Keys[k] = true;

  if(['arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();

  // Activation pouvoirs  — J1: Entrée, J2: F
  if(e.key === 'Enter') triggerPower(1);
  if(k==='f') triggerPower(2);

  // Activation SUPER pouvoirs — J1: ShiftRight, J2: Space
  if (e.code === 'ShiftRight') { e.preventDefault(); triggerSuperPower(1); }
  if (e.code === 'Space')      { e.preventDefault(); triggerSuperPower(2); }

 // pause / compte à rebours (inclut lancement initial)
if (k === 'p') {
  // 1) Pas encore démarré : on lit les options, on ferme le menu, on lance la partie + CR
  if (!Game.started) {
    if (UI.overlay) {
      readOptionsFromOverlay();
      UI.overlay.remove();
      UI.overlay = null;
    }
    startGame();         // crée le niveau et met Game.paused=true
    startCountdown(180); // lance tout de suite le compte à rebours initial
    e.preventDefault(); e.stopPropagation();
    return;
  }

  // 2) Si un compte à rebours est déjà en cours, on ignore P
  if (Game.countdown > 0) {
    e.preventDefault(); e.stopPropagation();
    return;
  }

  // 3) Sinon : toggle pause ↔ compte à rebours (reprise)
  if (Game.paused) startCountdown(180);
  else Game.paused = true;

  e.preventDefault(); e.stopPropagation();
  return;
}

  if(k==='o'){ openOverlay(); }
});

addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();

  if (anyPanelOpen() && ['arrowup','arrowdown','arrowleft','arrowright','enter','f','z','q','s','d'].includes(k)) {
    e.preventDefault();
    e.stopPropagation();
  }
  Keys[k] = false;
});


function triggerPower(pid){
  // Démarrage rapide si la partie n'est pas lancée
  if(!Game.started){ startGame(); return; }
  if(Game.countdown>0) return;

  const pl = (pid===1 ? Game.p1 : Game.p2);
  if(!pl) return;

// Si un panneau est déjà ouvert pour ce joueur → on ne fait rien ici
if (pl.panelActive) return;

  // Pas de relance si un pouvoir est en cours
  if (pl.powerTimer > 0) return;

  // Garde-fous des cooldowns "classiques"
  if (pl.species.id === 'phalloides' && pl.phaseCooldown > 0) return;
  if (pl.species.id === 'cornucopioides' && pl.trumpetCd > 0) return;

  // === Cas spéciaux (champignons 7 & 8) ===
  // 7) Stropharia — panel coop de 10s, immobile + invisible pour les parasites
  if (pl.species.id === 'stropharia'){
    pl.panelActive = true;
    pl.panelMode   = 'coop';
    pl.powerTimer  = 600;       // 10s @60fps
    pl.dir = [0,0]; pl.nextDir = [0,0];
    pl.inputLocked = true;      // ton updatePlayer doit ignorer le déplacement si ce flag est true
    pl.invisible   = true;      // indétectable par l’IA pendant le panel

    const el = (pid===1?UI.power1:UI.power2);
    if (el) el.textContent = 'Panel (10s)';

    if (typeof openPowerPanel === 'function') openPowerPanel(pl);
    sfxPower();
    return;
  }

  // 8) Anthurus — nécessite 10 spores pour ouvrir le panel (consomme exactement 10)
  if (pl.species.id === 'anthurus'){
    pl.anthurusCharge = (pl.anthurusCharge|0);
    if (pl.anthurusCharge < 10) {
      // pas assez chargé => rien (option: son d'erreur si tu veux)
      if (typeof refreshPowerHUD === 'function') refreshPowerHUD(pl);
      return;
    }
    // Consomme 10 spores (garde le surplus si >10)
    pl.anthurusCharge -= 10;

    pl.panelActive = true;
    pl.panelMode   = 'trap';
    pl.powerTimer  = 600;       // 10s @60fps
    pl.dir = [0,0]; pl.nextDir = [0,0];
    pl.inputLocked = true;      // immobile dans le labyrinthe (mais navigation dans le panel)

    const el = (pid===1?UI.power1:UI.power2);
    if (el) el.textContent = 'Panel (10s)';

    if (typeof openPowerPanel === 'function') openPowerPanel(pl);
    if (typeof refreshPowerHUD === 'function') refreshPowerHUD(pl);
    sfxPower();
    return;
  }

  // === Comportement par défaut : déclenche le pouvoir de l'espèce ===
  const beforeTimer = pl.powerTimer|0;

  pl.species.use(pl);

  // Bonus d'extension accumulé par des bonus "power"
  if (pl.nextPowerExtend && pl.nextPowerExtend > 0){
    pl.powerTimer += pl.nextPowerExtend;
    pl.nextPowerExtend = 0;
  }

  // On ne met à jour HUD + SFX que si l'activation a VRAIMENT démarré (timer > avant)
  if ((pl.powerTimer|0) > beforeTimer){
    const el = (pid===1?UI.power1:UI.power2);
    if (el) el.textContent = pl.species.power || 'Pouvoir';
    sfxPower();
  }
}

function triggerSuperPower(pid){
  // Pas de partie => on démarre de suite la partie comme triggerPower
  if(!Game.started){ startGame(); return; }
  if(Game.countdown>0) return;

  const pl = (pid===1 ? Game.p1 : Game.p2);
  if(!pl) return;
  if (!pl.superPowerHeld) return; // rien en poche

  // on consomme le stock
  pl.superPowerHeld = false;
  const hudEl = (pid===1?UI.power1:UI.power2);
  if (hudEl) hudEl.textContent = '★ utilisé';

  // Effet "super" : si le pouvoir n'est pas actif, on le démarre d'abord
  const addFrames = 120; // +2 s @60fps
  if (pl.powerTimer <= 0){
    const before = pl.powerTimer|0;
    // Respecte les garde-fous usuels ? Ici on CHOISIT de bypass le cooldown pour un effet "super"
    pl.species.use(pl);
    if ((pl.powerTimer|0) > before){
      if (hudEl) hudEl.textContent = pl.species.power || 'Pouvoir';
      sfxPower();
    }
  }
  // Dans tous les cas, on ajoute +2 s
  pl.powerTimer += addFrames;

  // petit feedback audio/visuel en plus si tu veux
  sfxPower();
}

  

/* ============ Utils ============ */
const now=()=>performance.now();
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
// --- Orientation parasites (quart de tour) ---
function angleFromDir4(d){
  if(!d) return null;
  const [dx,dy] = d;
  if (dy < 0 && dx === 0) return 0;             // haut (sprite natif)
  if (dx > 0 && dy === 0) return Math.PI/2;     // droite
  if (dy > 0 && dx === 0) return Math.PI;       // bas
  if (dx < 0 && dy === 0) return -Math.PI/2;    // gauche
  return null;
}
function normAngle(a){
  while(a <= -Math.PI) a += Math.PI*2;
  while(a >   Math.PI) a -= Math.PI*2;
  return a;
}
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

// Planifie un quart de tour (±90°). Si l'écart est de 180°, on fera 2 quarts successifs.
function scheduleQuarterTurn(p, targetAngle){
  const cur = p.faceAngle || 0;
  const delta = normAngle(targetAngle - cur);
  const step = Math.sign(delta) * Math.min(Math.PI/2, Math.abs(delta));
  p.turnFromAngle = cur;
  p.turnToAngle   = cur + step;
  p.turnTimer     = p.turnDuration || 6; // ~6 frames
  p.pendingAngle  = (Math.abs(delta) > Math.PI/2 + 0.001) ? targetAngle : null;
}

// À appeler 1x par frame (animer + déclencher si besoin)
function updateParasiteOrientation(p, dt){
  // Animation en cours ?
  if ((p.turnTimer||0) > 0){
    p.turnTimer -= dt;
    const t  = Math.max(0, Math.min(1, 1 - (p.turnTimer / (p.turnDuration||6))));
    const tt = easeOutCubic(t);
    p.faceAngle = lerp(p.turnFromAngle||0, p.turnToAngle||0, tt);
    if (p.turnTimer <= 0){
      p.faceAngle = p.turnToAngle||0;
      if (p.pendingAngle != null){
        const diff = normAngle(p.pendingAngle - p.faceAngle);
        if (Math.abs(diff) > 0.001) scheduleQuarterTurn(p, p.pendingAngle);
        else p.pendingAngle = null;
      }
    }
    return;
  }
  // Sinon : regarde si la direction courante impose un nouveau quart de tour
  const target = angleFromDir4(p.dir);
  if (target == null) return;             // pas de direction (immobile)
  const diff = normAngle(target - (p.faceAngle||0));
  if (Math.abs(diff) > 0.01) scheduleQuarterTurn(p, target);
}

const distance=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
const makeLayerCanvas=(w,h)=>{ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; };
// === HUD Leader (visible UNIQUEMENT en mode 2 joueurs) ===
function updateLeaderHUD(){
  if (!UI.leaderPill || !UI.leaderText) return;

  if (Game.mode !== 'duo') {
    // Solo -> rien
    UI.leaderPill.style.display = 'none';
    UI.leaderText.textContent = '—';
    return;
  }

  // Duo -> on montre la pastille
  UI.leaderPill.style.display = '';
  let txt = 'Égalité';
  if (Game.score1 > Game.score2) txt = 'J1 en tête';
  else if (Game.score2 > Game.score1) txt = 'J2 en tête';
  UI.leaderText.textContent = txt;
}

  function refreshPowerHUD(pl){
  const el = (pl.pid===1?UI.power1:UI.power2);
  if (pl.species.id==='anthurus'){
    if (pl.panelActive || pl.powerTimer>0) el.textContent = 'Panel (10s)';
    else el.textContent = (pl.anthurusCharge|0) + '/10';
  }
}


/* ============ Audio (SFX uniquement — musique via <audio id="bgm">) ============ */
let ACTX = null, MASTER = null, STARTED = false;

// Initialise le contexte audio pour les effets sonores SEULEMENT (plus de musique synthé)
function ensureAudio(){
  if (STARTED) return;
  STARTED = true;
  ACTX = new (window.AudioContext || window.webkitAudioContext)();
  MASTER = ACTX.createGain();
  MASTER.gain.value = 0.18;
  MASTER.connect(ACTX.destination);
}

// Générateur d’effets (bips) pour le gameplay
function tone(time,freq,dur,type='sine',vol=0.2){
  if(!ACTX) return;
  const o=ACTX.createOscillator(), g=ACTX.createGain();
  o.type=type;
  o.frequency.setValueAtTime(freq,time);
  g.gain.value=0;
  g.gain.linearRampToValueAtTime(vol,time+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001,time+dur);
  o.connect(g); g.connect(MASTER);
  o.start(time); o.stop(time+dur);
}

// Effets sonores conservés
function sfxEat(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,740,.05,'triangle',.2); }
function sfxPower(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,520,.1,'sawtooth',.22); tone(t+.1,880,.1,'square',.18); }
function sfxHit(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,160,.08,'sawtooth',.3); }
function sfxWin(){ if(!ACTX) return; const t=ACTX.currentTime; [660,880,990,1320].forEach((f,i)=>tone(t+i*.1,f,.1,'triangle',.2)); }
function sfxLife(){ if(!ACTX) return; const t=ACTX.currentTime; [660,990,1320].forEach((f,i)=>tone(t+i*.08,f,.08,'sine',.22)); }

// On crée le contexte SFX au premier clic sur le canvas (aucune musique n’est lancée ici)
CANVAS.addEventListener('click', ensureAudio);


/* ============ Dessin entités ============ */
function drawTrumpet(ctx, cx, cy, size, icon, ghost){
  const p = getSpritePath('cornucopioides', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, !!ghost);
}
function drawAmanita(ctx, cx, cy, size, icon){
  const p = getSpritePath('muscaria', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawChanterelle(ctx, cx, cy, size, icon){
  const p = getSpritePath('cibarius', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawCep(ctx, cx, cy, size, icon){
  const p = getSpritePath('edulis', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawMorel(ctx, cx, cy, size, icon){
  const p = getSpritePath('morchella', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawPhalloides(ctx, cx, cy, size, icon){
  const p = getSpritePath('phalloides', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawStropharia(ctx, cx, cy, size, icon){
  const p = getSpritePath('stropharia', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawAnthurus(ctx, cx, cy, size, icon){
  const p = getSpritePath('anthurus', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}

/* ============ Parasites (ennemis) ============ */
function drawParasiteSprite(p){
  const idx = Math.max(1, Math.min(7, p.kind || 1));
  const path = PARASITE_SPRITES[idx];
  const img  = loadImg(path);
  if (!img.complete) return;

  const cx = p.x * TILE, cy = p.y * TILE;
  const size = TILE * 0.95;

  // Glow serviteur (avant le sprite)
  if (p.servant){
    CTX.save();
    CTX.globalAlpha = 0.8;
    const r = size * 0.42;
    const g = CTX.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.25);
    g.addColorStop(0, 'rgba(223,255,248,0.95)');
    g.addColorStop(0.5, 'rgba(64,224,208,0.70)');
    g.addColorStop(1, 'rgba(26,140,134,0.0)');
    CTX.fillStyle = g;
    CTX.beginPath(); CTX.arc(cx, cy, r*1.2, 0, Math.PI*2); CTX.fill();
    CTX.restore();
  }

  // Sprite + rotation (0 rad = tête vers le haut)
  CTX.save();
  CTX.translate(cx, cy);
  CTX.rotate(p.faceAngle || 0);
  CTX.drawImage(img, -size/2, -size/2, size, size);
  CTX.restore();

  // Indicateurs (optionnels)
  if (p.confusedTimer > 0){
    CTX.save();
    CTX.globalAlpha = 0.9;
    CTX.font = '12px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.fillStyle = '#fff';
    CTX.fillText('✳', cx, cy - TILE*0.6);
    CTX.restore();
  }
  if (p.blind > 0){
    CTX.save();
    CTX.globalAlpha = 0.55;
    const w = size * 0.6, h = size * 0.16;
    CTX.fillStyle = '#000';
    CTX.fillRect(cx - w/2, cy - h/2, w, h);
    CTX.restore();
  }
}


/* ============ Espèces & pouvoirs ============ */
const Species = [
{
  id: 'cornucopioides',
  name: 'Trompette de la mort',
  power: `Voile d'ombre`,
  desc: 'Devient invisible (la durée augmente en collectant les spores) mais se déplace plus lentement.',
  color: '#3d3630',
  draw: (c,x,y,s,icon,ghost) => drawTrumpet(c,x,y,s,icon,ghost),
  use: (me) => {
    // Durée dynamique : 1 seconde par tranche de 5 spores collectées
    const sec = Math.floor((me.collectedSpores || 0) / 5);
    const frames = sec * 60;

    // Si 0 spore → aucun effet (on ne lance pas le pouvoir)
    if (frames <= 0) {
      (me.pid===1 ? UI.power1 : UI.power2).textContent = '—';
      return;
    }

    // Activation du voile : invisibilité, vitesse réduite, pas d’immunité pièges
    me.powerTimer = frames;
    me.invisible  = true;    // indétectable pour l’IA
    me.speedBoost = 0.5;     // -50% de vitesse
    me.trumpetTrapImmune = false; // plus d’immunité aux pièges
  }
},

{
  id: 'muscaria',
  name: 'Amanite tue-mouches',
  power: 'Piège mycotique',
  desc: 'Pose des pièges qui téléportent les parasites ailleurs sur la carte.',
  color: '#c81d1d',
  draw: drawAmanita,
  use: (me) => {
    const tx = Math.floor(me.x), ty = Math.floor(me.y);
    if (me.pid===1) Game.muscariaTrap1 = {x:tx,y:ty,active:true};
    else            Game.muscariaTrap2 = {x:tx,y:ty,active:true};
    me.powerTimer = 120;
  }
},

{
  id: 'cibarius',
  name: 'Girolle',
  power: 'Serviteur parasite',
  desc: 'Peut capturer un parasite et le transforme temporairement en allié collecteur.',
  color: '#e6a100',
  draw: drawChanterelle,
  use: (me) => {
    me.powerTimer = 15*60;   // ~15s
    me.hunterWindow = 600;   // fenêtre de capture (10s)
    UI[me.pid===1 ? 'power1' : 'power2'].textContent = 'Serviteur ?';

    Game.girollePanic.active = true;
    Game.girollePanic.ownerPid = me.pid;
    Game.parasites.forEach(p => { p.fleeGirolle = me.hunterWindow; });
  }
},

{
  id: 'edulis',
  name: 'Cèpe',
  power: 'Robustesse',
  desc: 'Encaisse un coup sans perdre de vie et repousse l’ennemi en cascade.',
  color: '#7a4f2a',
  draw: drawCep,
  use: (me) => { me.powerTimer=360; me.shield=true; }
},

{
  id: 'morchella',
  name: 'Morille',
  power: 'Spores du chaos',
  desc: 'Libère des spores qui désorientent les parasites et troublent l’adversaire.',
  color: '#6a4f2f',
  draw: drawMorel,
  use: (me) => {
    me.powerTimer = 600; // 10s d'aura
    const radTiles = Math.max(1, Math.floor(0.20 * Math.max(COLS, ROWS)));
    const cx = me.x, cy = me.y;

    Game.parasites.forEach(p => {
      if (Math.hypot(p.x-cx, p.y-cy) <= radTiles) {
        p.morilleChaos = 600;
        p.morilleOwner = me.pid;
        p.morilleNextSwitch = 0;
        p.morilleMode = null;
      }
    });
    spawnSporeCloud(me.x, me.y, radTiles);

    if (Game.mode === 'duo') {
      const foe = (me.pid === 1) ? Game.p2 : Game.p1;
      if (foe) {
        const dist = Math.hypot(foe.x - cx, foe.y - cy);
        if (dist <= radTiles) {
          foe.madnessTimer = 300; // 5s @60fps
          sfxPower();
          foe.glowTimer = Math.max(foe.glowTimer||0, 60);
        }
      }
    }
  }
},

{
  id: 'phalloides',
  name: 'Amanite phalloïde',
  power: 'Phase mycélienne',
  desc: `Peut traverser une rangée d'arbres (mur intérieur du labyrinthe).`,
  color: '#7a8b4b',
  draw: drawPhalloides,
  use: (me) => {
    if (me.phaseCooldown > 0) return;
    me.phase = true;
    me.phaseInsideWall = false;
    me.powerTimer = 99999; // on coupera après sortie du 1er mur
  }
},

{
  id: 'stropharia',
  name: 'Strophaire Vert-de-gris',
  power: 'Assistance symbiotique',
  desc: `Coopère avec l'autre champignon et l'assiste pour éviter les parasites.`,
  color: '#6bb08f',
  draw: drawStropharia,
  use: ()=>{} // géré par triggerPower()
},

{
  id: 'anthurus',
  name: `Anthurus d'archer`,
  power: 'Extinction de la concurrence',
  desc: 'Allié des parasites, il met en place des pièges et des sabotages pour nuire au champignon adverse.',
  color: '#b04a6b',
  draw: drawAnthurus,
  use: ()=>{} // géré par triggerPower()
}
];

let Selected1=Species[0], Selected2=Species[1];

/* =================== OVERLAY / MENU =================== */
function buildChoiceCard(sp, forPid){
  const otherSel = (forPid===1)? Selected2 : Selected1;
  const disabled = (Game && Game.mode==='duo' && otherSel && (
  otherSel.id===sp.id ||
  ((otherSel.id==='stropharia' && sp.id==='anthurus') ||
   (otherSel.id==='anthurus'  && sp.id==='stropharia'))
));

  const div=document.createElement('div');
  div.className='choice'+(disabled?' disabled':'');
  div.style.cssText = 'background:#0e0b13;border:1px solid #ffffff1f;border-radius:12px;padding:14px;cursor:pointer;display:flex;gap:12px;align-items:center;';
  
  const icon = document.createElement('img');
  icon.src = getSpritePath(sp.id, true);
  icon.alt = sp.name;
  icon.style.cssText = 'width:84px;height:84px;object-fit:contain;image-rendering:crisp-edges;flex:0 0 auto;';

  const right=document.createElement('div'); right.style.display='grid'; right.style.gap='4px';
  const name=document.createElement('div'); name.style.fontWeight='800'; name.textContent=sp.name;
  const desc=document.createElement('div'); desc.style.opacity='.85'; desc.style.fontSize='13px'; desc.textContent='Pouvoir : '+sp.power+' — '+sp.desc;

  const row=document.createElement('div'); row.className='row';
  const badge=document.createElement('span'); badge.className='badge'; badge.textContent=sp.id;
  row.appendChild(badge);

  right.appendChild(name); right.appendChild(desc); right.appendChild(row);
  div.appendChild(icon); div.appendChild(right);

  if(!disabled){
    div.addEventListener('click', ()=>{
      if(forPid===1) Selected1=sp; else Selected2=sp;
      renderChoices(); updateStartButtonState();
    });
    div.addEventListener('dblclick', ()=>{
      if(updateStartButtonState()) { readOptionsFromOverlay(); startGame(); }
    });
  }
  const sel = forPid===1?Selected1:Selected2;
  if(sel && sel.id===sp.id){ div.style.outline='2px solid '+sp.color; div.style.boxShadow='0 0 0 4px '+sp.color+'33'; }

  return div;
}

function renderChoices(){
  const isDuo = (UI.overlay?.querySelector('input[name="modeSel"]:checked')?.value === 'duo');
  const list = isDuo ? Species : Species.filter(s => s.id!=='stropharia' && s.id!=='anthurus');

  // J1 : toujours affiché
  if(UI.choices1){
    UI.choices1.innerHTML='';
    list.forEach(sp=>UI.choices1.appendChild(buildChoiceCard(sp,1)));
  }

  // J2 : uniquement en mode duo
  if(UI.choices2){
    UI.choices2.innerHTML='';
    if(isDuo){
      list.forEach(sp=>UI.choices2.appendChild(buildChoiceCard(sp,2)));
    }
  }
}


function updateStartButtonState(){
  if(!UI.overlay) return false;
const duo = (UI.overlay.querySelector('input[name="modeSel"]:checked')?.value==='duo');
const pair7v8 = (duo && Selected1 && Selected2 &&
                 ((Selected1.id==='stropharia' && Selected2.id==='anthurus') ||
                  (Selected1.id==='anthurus'  && Selected2.id==='stropharia')));
const conflict = (duo && Selected1 && Selected2 && (Selected1.id===Selected2.id || pair7v8));
  const btn = UI.startBtn;
  if(btn){
    btn.disabled = !!conflict;
    btn.textContent = conflict ? "Choisissez deux espèces différentes" : "Jouer";
  }
  return !conflict;
}

function readOptionsFromOverlay(){
  const root=UI.overlay||document;
  const sel=root.querySelector('#diffSel');
  if(sel){
    const found=DIFFICULTIES.find(d=>d.id===sel.value);
    if(found) SelectedDifficulty=found;
  }
  const modeSel=root.querySelector('input[name="modeSel"]:checked');
  if(modeSel){ Game.mode=modeSel.value; }
  if(Game.mode==='duo' && Selected1 && Selected2 && Selected1.id===Selected2.id){
    const alt = Species.find(s=>s.id!==Selected1.id);
    if(alt) Selected2 = alt;
  }
}

function attachOverlayEvents(ov){
  const btn=ov.querySelector('#startBtn');
  if(btn){
    btn.addEventListener('click', ()=>{
      if(!updateStartButtonState()) return;
      readOptionsFromOverlay();
      startGame();
    });
  }
  ov.addEventListener('change',(e)=>{
  if(e.target && e.target.name==='modeSel'){
  renderChoices();
  updateStartButtonState();

  // Toggle visibilité J2 selon le mode
  const duo = (ov.querySelector('input[name="modeSel"]:checked')?.value === 'duo');
  ov.querySelector('#secVar2').style.display = duo ? '' : 'none';
  ov.querySelector('#choices2').style.display = duo ? 'grid' : 'none';
}

  });
 ov.addEventListener('keydown', (e)=>{
  if ((e.key === 'Enter' || e.key === ' ') && updateStartButtonState()){
    e.preventDefault();
    e.stopPropagation(); // <<< évite le 2e start via le listener global
    readOptionsFromOverlay();
    startGame();
  }
});
}

// === Helpers Panneau (globaux) ===
function getPowerPanelEntries(pl){
  const tx = Math.floor(pl.x), ty = Math.floor(pl.y);
  const foe = (pl.pid===1 ? Game.p2 : Game.p1);
  const dm = gridDims(), C=dm.cols, R=dm.rows;
  const isInterior = (x,y)=> (x>0 && y>0 && x<C-1 && y<R-1);

  const entries = [];

if (pl.species.id === 'stropharia'){
  entries.push({
    label: 'Planter un arbre (mur)',
    action: ()=>{ 
      if (Game.grid[ty][tx]!==1){
        safeSetWallWithAntiSeal(tx, ty, foe);
        refreshPelletCell(tx,ty);
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Abattre un arbre (devant)',
    action: ()=>{
      const f = frontTile(pl);
      if (isInterior(f.tx,f.ty) && Game.grid[f.ty][f.tx]===1){
        Game.grid[f.ty][f.tx]=2;
        redrawWallIfAny(f.tx,f.ty);
        addPelletCell(f.tx,f.ty);
        // si c’était le mur "clé" de l’adversaire, on purge
        if (Game.sealWallFor[foe.pid] &&
            Game.sealWallFor[foe.pid].x===f.tx &&
            Game.sealWallFor[foe.pid].y===f.ty){
          Game.sealWallFor[foe.pid] = null;
        }
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Planter bonus Vitesse (allié)',
    action: ()=>{
      const b = backTile(pl);
      if (isInterior(b.tx,b.ty) && Game.grid[b.ty][b.tx]!==1){
        Game.grid[b.ty][b.tx]=3; refreshPelletCell(b.tx,b.ty);
        Game.bonuses.push({x:b.tx,y:b.ty,kind:'speed'});
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Planter bonus Freeze',
    action: ()=>{
      const b = backTile(pl);
      if (isInterior(b.tx,b.ty) && Game.grid[b.ty][b.tx]!==1){
        Game.grid[b.ty][b.tx]=3; refreshPelletCell(b.tx,b.ty);
        Game.bonuses.push({x:b.tx,y:b.ty,kind:'freeze'});
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Créer un vortex (10s)',
    action: ()=>{
      const b = backTile(pl);
      if (isInterior(b.tx,b.ty) && Game.grid[b.ty][b.tx]!==1){
        refreshPelletCell(b.tx,b.ty);
        spawnTemporaryVortex(b.tx,b.ty,600);
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Désactiver pièges à proximité',
    action: ()=>{ disableNearbyTraps(tx,ty,3); sfxPower(); }
  });
}


 if (pl.species.id === 'anthurus'){
  entries.push({
    label: 'Planter un arbre (mur)',
    action: ()=>{
      if (Game.grid[ty][tx]!==1){
        placeWallWithSealTracking(tx, ty, pl, foe);
        refreshPelletCell(tx,ty);
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Abattre un arbre (devant)',
    action: ()=>{
      const f = frontTile(pl);
      if (isInterior(f.tx,f.ty) && Game.grid[f.ty][f.tx]===1){
        Game.grid[f.ty][f.tx]=2;
        redrawWallIfAny(f.tx,f.ty);
        addPelletCell(f.tx,f.ty);
        // si c’était le mur "clé" mémorisé, purge
        if (Game.sealWallFor[foe.pid] &&
            Game.sealWallFor[foe.pid].x===f.tx &&
            Game.sealWallFor[foe.pid].y===f.ty){
          Game.sealWallFor[foe.pid] = null;
        }
        sfxPower();
      }
    }
  });
  entries.push({
    label: 'Envoyer un nouveau parasite',
    action: ()=>{ spawnEnemy(); sfxPower(); }
  });
  entries.push({
    label: 'Créer un piège (ovale vert)',
    action: ()=>{
      const b = backTile(pl);
      if (isInterior(b.tx,b.ty) && Game.grid[b.ty][b.tx]!==1){
        Game.grid[b.ty][b.tx]=4;
        Game.traps.push({x:b.tx,y:b.ty,t:1});
        refreshPelletCell(b.tx,b.ty);
        sfxPower();
      }
    }
  });
}

  return entries;
}

function powerPanelConfirm(pl, evt){
  if (evt) { evt.preventDefault(); evt.stopPropagation(); }

  // 1) UI OFF + mobilité ON
  pl.powerTimer = 0;
  pl.inputLocked = false;
  pl.panelActive = false;
  pl.invisible = false;
  pl.hiddenFromParasites = false;

  const el = (pl.pid===1?UI.power1:UI.power2);
  if (el) el.textContent = '—';

  closePowerPanel(pl); // retire le listener 'keydown' du panneau

  // 2) Purge immédiate des touches de navigation/validation
  ['arrowup','arrowdown','arrowleft','arrowright','z','q','s','d','enter','f'].forEach(k => { Keys[k] = false; });

  // 3) Exécuter l’action sélectionnée au prochain tick (panneau déjà fermé)
  const entries = getPowerPanelEntries(pl);
  const i = (pl.panelSel|0);
  const act = entries[i] && entries[i].action;
  if (typeof act === 'function') setTimeout(() => act(), 0);
}

  
function openPowerPanel(pl){
  closePowerPanel(pl); // sécurité
  pl.panelActive = true;
  pl.panelSel = 0;
  pl.hiddenFromParasites = true; // non-ciblable tant que le panel est ouvert

  const side = (pl.pid===1) ? 'right:8px; left:auto;' : 'left:8px; right:auto;';
  const panel = document.createElement('div');
  panel.className='card';
  panel.style.cssText = `
    position:fixed; top:8px; ${side} z-index:9998; width:260px; max-height:calc(100vh - 16px);
    background:var(--card); border:1px solid var(--line); border-radius:12px; padding:12px; overflow:auto;
  `;
  panel.id = `powerPanel_${pl.pid}`;

  const title = document.createElement('div');
  title.className='title';
  title.style.fontSize='18px';
  title.textContent = (pl.species.id==='stropharia') ? 'Aide coop (10s)' : 'Sabotage (10s)';
  panel.appendChild(title);

  const list = document.createElement('div');
  list.id = `powerList_${pl.pid}`;
  panel.appendChild(list);

  function render(){
    const entries = getPowerPanelEntries(pl);
    list.innerHTML='';
    entries.forEach((e,i)=>{
      const item = document.createElement('div');
      item.className='choice';
      item.style.cssText='padding:8px;border:1px solid var(--line);border-radius:8px;margin-top:8px;cursor:pointer;background:#0e0b13;';
      if(i===pl.panelSel){ item.style.outline='2px solid #8fd0ff'; item.style.boxShadow='0 0 0 3px #8fd0ff33'; }
      item.textContent = e.label;
      item.onclick = (evt) => {
  evt.preventDefault(); evt.stopPropagation();
  pl.panelSel = i;
  powerPanelConfirm(pl, evt);
};

      list.appendChild(item);
    });
  }
  render();

function onKey(e){
  const k = e.key.toLowerCase();
  const up = (pl.pid===1) ? 'arrowup' : 'z';
  const down = (pl.pid===1) ? 'arrowdown' : 's';
  const ok = (pl.pid===1) ? 'enter' : 'f';

  if (k===up){
    pl.panelSel = (pl.panelSel-1+getPowerPanelEntries(pl).length)%getPowerPanelEntries(pl).length;
    render();
    e.preventDefault(); e.stopPropagation();
  }
  else if (k===down){
    pl.panelSel = (pl.panelSel+1)%getPowerPanelEntries(pl).length;
    render();
    e.preventDefault(); e.stopPropagation();
  }
  else if (k===ok){
    powerPanelConfirm(pl, e);
    // e.preventDefault() est fait dans powerPanelConfirm
  }
}
panel._onKey = onKey;
document.addEventListener('keydown', onKey);


  document.body.appendChild(panel);
  pl._panelEl = panel;
  refreshPowerHUD(pl);
}

function closePowerPanel(pl){
  if(!pl || !pl._panelEl) return;
  document.removeEventListener('keydown', pl._panelEl._onKey);
  pl.panelActive = false;
  pl.hiddenFromParasites = false;
  pl._panelEl.remove(); pl._panelEl = null;
  refreshPowerHUD(pl);
}

  
function createOverlay(){
  if(UI.overlay) return;
  const ov=document.createElement('div'); ov.className='ov'; ov.id='overlay'; ov.setAttribute('role','dialog'); ov.setAttribute('aria-modal','true'); ov.tabIndex=0;
  const card=document.createElement('div'); card.className='card'; ov.appendChild(card);

  const title=document.createElement('div'); title.className='title'; title.textContent='🍄 PACMUSH ODYSSEY 🍄';
  const sub=document.createElement('div'); sub.className='sub'; sub.textContent='Choisis le mode, la difficulté et vos champignons (en 2J : espèces différentes).';

  // Mode
  const secMode=document.createElement('div'); secMode.className='sectionTitle'; secMode.textContent='Mode de jeu';
  const rowMode=document.createElement('div'); rowMode.className='row';
  const r1=document.createElement('label'); r1.className='badge'; r1.style.cursor='pointer';
  r1.innerHTML='<input type="radio" name="modeSel" value="solo" checked> Solo';
  const r2=document.createElement('label'); r2.className='badge'; r2.style.cursor='pointer';
  r2.innerHTML='<input type="radio" name="modeSel" value="duo"> 2 joueurs (même clavier)';
  rowMode.appendChild(r1); rowMode.appendChild(r2);

  // Difficulté
  const secDiff=document.createElement('div'); secDiff.className='sectionTitle'; secDiff.textContent='Difficulté';
  const rowDiff=document.createElement('div'); rowDiff.className='row';
  const lab=document.createElement('label'); lab.textContent='Mode :'; lab.className='badge'; lab.setAttribute('for','diffSel');
  const sel=document.createElement('select'); sel.id='diffSel'; sel.className='select'; sel.style.cssText='background:#0e0b13;border:1px solid #ffffff22;border-radius:8px;padding:8px 10px;color:#fff7ea';
  DIFFICULTIES.forEach(d=>{
    const o=document.createElement('option'); o.value=d.id; o.textContent=d.label; if(d.id===SelectedDifficulty.id) o.selected=true; sel.appendChild(o);
  });
  rowDiff.appendChild(lab); rowDiff.appendChild(sel);

  // Choix champignons
  const secVar1=document.createElement('div'); secVar1.className='sectionTitle'; secVar1.textContent='Joueur 1 — Variété';
  const grid1=document.createElement('div'); grid1.id='choices1'; grid1.className='grid';
  const secVar2=document.createElement('div'); secVar2.className='sectionTitle'; secVar2.id='secVar2'; secVar2.textContent='Joueur 2 — Variété (mode 2J)';
  const grid2=document.createElement('div'); grid2.id='choices2'; grid2.className='grid';

  const footer=document.createElement('div'); footer.className='row'; footer.style.justifyContent='space-between'; footer.style.marginTop='12px';
  const rowL=document.createElement('div'); rowL.className='row';
  ['J1: Flèches/Entrée','J2: ZQSD/F','P: pause + CR 3s (début)','O: menu'].forEach(t=>{ const b=document.createElement('span'); b.className='badge'; b.textContent=t; rowL.appendChild(b); });
  const btn=document.createElement('button'); btn.id='startBtn'; btn.textContent='Jouer'; btn.className='btn';
  footer.appendChild(rowL); footer.appendChild(btn);

  card.appendChild(title); card.appendChild(sub);
  card.appendChild(secMode); card.appendChild(rowMode);
  card.appendChild(secDiff); card.appendChild(rowDiff);
  card.appendChild(secVar1); card.appendChild(grid1);
  card.appendChild(secVar2); card.appendChild(grid2);
  card.appendChild(footer);

  document.body.appendChild(ov);
  UI.overlay=ov; UI.choices1=grid1; UI.choices2=grid2; UI.startBtn=btn; attachOverlayEvents(ov);
  renderChoices(); updateStartButtonState();
  setTimeout(()=>ov.focus(),0);

  // Cache J2 si on est en Solo au chargement
const duoInit = ov.querySelector('input[name="modeSel"]:checked')?.value === 'duo';
ov.querySelector('#secVar2').style.display = duoInit ? '' : 'none';
ov.querySelector('#choices2').style.display = duoInit ? 'grid' : 'none';
}

function openOverlay(){
  if(UI.overlay) return;
  Game.paused=true; Game.countdown=0;
  createOverlay();
}

function startGame(){
  if(UI.overlay){ UI.overlay.remove(); UI.overlay=null; }

  // AJOUT : purge défensive des anciens états (si des joueurs existent)
  if (Game.p1) resetPlayerRuntimeState(Game.p1);
  if (Game.p2) resetPlayerRuntimeState(Game.p2);
  UI.power1.textContent = '—';
  UI.power2.textContent = '—';

  ensureAudio();
  Game.started=true;

  reseedSession(1);

  Game.showStartHint = 0;
  resetMatch(true);
  updateLeaderHUD();
  UI.diff.textContent=SelectedDifficulty.name;
}


/* =================== BIOMES, ARBRES (EMOJI) & GÉNÉRATION =================== */
const BIOMES=[
  {name:'Forêt humide', sky1:'#2c1f35', sky2:'#0d0a12', moss:'#3fbf7f', soil:'#3b2a21', fog:'#ffffff0f', wall:'#3a2e43', deco:'#95e8b6'},
  {name:'Clairière dorée', sky1:'#4a2b1a', sky2:'#1a0e08', moss:'#ffd166', soil:'#5a3b2b', fog:'#ffd1660f', wall:'#5a3b2b', deco:'#ffd98a'},
  {name:'Sous-bois bleuté', sky1:'#203248', sky2:'#0a0f16', moss:'#64d7ff', soil:'#2b303a', fog:'#64d7ff12', wall:'#314459', deco:'#9fe4ff'},
  {name:'Mousse émeraude', sky1:'#153022', sky2:'#08120c', moss:'#2fd07a', soil:'#1c2a21', fog:'#2fd07a12', wall:'#1e3a2f', deco:'#4ef1a8'}
];
let LEVEL_INDEX=0; let BIOME=BIOMES[0];

function mulberry32(seed){ let a=(seed>>>0)||0x9E3779B9; return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
function isGridShape(grid,c,r){ if(!Array.isArray(grid)||grid.length!==r) return false; for(let y=0;y<r;y++){ if(!Array.isArray(grid[y])||grid[y].length!==c) return false; } return true; }
function genLevel(seed){ const rng=mulberry32(seed==null? (Math.random()*1e9)|0:seed); let maze=createMaze(COLS,ROWS,rng); if(!isGridShape(maze,COLS,ROWS)) maze=createMaze(COLS,ROWS,mulberry32(0xDEADBEEF)); decorateMaze(maze,rng); return maze; }
function createMaze(w,h,rng){
  w=Math.max(5,w|0); h=Math.max(5,h|0);
  const g=Array.from({length:h},()=>Array.from({length:w},()=>1));
  const stack=[]; const start=[1,1]; g[1][1]=0; stack.push(start);
  const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
  while(stack.length){
    const last=stack[stack.length-1]; const cx=last[0], cy=last[1];
    for(let i=dirs.length-1;i>0;i--){ const j=(rng()*(i+1))|0; const tmp=dirs[i]; dirs[i]=dirs[j]; dirs[j]=tmp; }
    let carved=false;
    for(let d=0;d<dirs.length;d++){
      const dx=dirs[d][0], dy=dirs[d][1]; const nx=cx+dx, ny=cy+dy;
      if(nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
      if(g[ny][nx]===1){ g[cy+dy/2][cx+dx/2]=0; g[ny][nx]=0; stack.push([nx,ny]); carved=true; break; }
    }
    if(!carved) stack.pop();
  }
  for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(g[y][x]===0) g[y][x]=2; // spores
  for(let x=0;x<w;x++){ g[0][x]=1; g[h-1][x]=1;}
  for(let y=0;y<h;y++){ g[y][0]=1; g[y][w-1]=1;}
  return g;
}
function decorateMaze(g, rng){
  if(!Array.isArray(g)||!g.length||!Array.isArray(g[0])) return g;
  const h=g.length,w=g[0].length;

  // Élargissements locaux connectés (pas de "salles" isolées)
  const holes = ((w*h)/180)|0; // ~proportion douce selon la taille
  for(let n=0;n<holes;n++){
    let tries=24;
    while(tries--){
      const x = 1 + ((rng()*(w-2))|0);
      const y = 1 + ((rng()*(h-2))|0);
      if (g[y][x]===1){
        // On ne transforme en 2 que si au moins un voisin est déjà ouvert
        if (g[y][x-1]===2 || g[y][x+1]===2 || g[y-1][x]===2 || g[y+1][x]===2){
          g[y][x]=2;
          break;
        }
      }
    }
  }

   // Distribution aléatoire mais bornée de bonus/pièges ...
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      if(g[y][x]===2){
        const r=rng();
        if(r<0.03) g[y][x]=4;       // piège
        else if(r<0.08) g[y][x]=3;  // bonus
      }
    }
  }

  // --- AJOUT : petites placettes aléatoires (garanties connectées)
  // --- paramètres ADAPTATIFS en fonction de la carte ---
const area   = w * h;
const minDim = Math.min(w, h);

// tailles (demi-axes), bornées
const halfMin = Math.max(1, Math.min(4, (minDim * 0.02) | 0));
const halfMax = Math.max(halfMin + 1, Math.min(6, (minDim * 0.06) | 0));

// quantités, croissent avec l'aire, bornées
const countMin = Math.max(2, Math.min(8,  (area / 1500) | 0));
const countMax = Math.max(countMin + 1, Math.min(12, (area /  900) | 0));

// appel avec paramètres adaptatifs
carveRandomPlacettes(g, rng, countMin, countMax, halfMin, halfMax);

  return g;
}


// Ouvre N petites "placettes" (salles) rectangulaires, tailles variables, connectées aux couloirs existants.
// g : grille (0..4/5), rng : PRNG mulberry32
function carveRandomPlacettes(g, rng, countMin=2, countMax=5, halfMin=1, halfMax=3) {
  const H = g.length|0; if (H<=0) return g;
  const W = (g[0]||[]).length|0; if (W<=0) return g;

  // utilitaires
  const inb = (x,y)=> (x>1 && y>1 && x<W-2 && y<H-2);
  const open = (x,y)=>{ if (inb(x,y) && g[y][x]===1) g[y][x]=2; };

  // nombre de placettes aléatoire
  const nPlac = Math.max(countMin, Math.min(countMax, (countMin + ((rng()*(countMax-countMin+1))|0)) ));

  // essaie de partir d'une case déjà ouverte (2) pour garantir la connexion
  function pickOpen() {
    for (let tries=0; tries<200; tries++){
      const x = 2 + ((rng()*(W-4))|0);
      const y = 2 + ((rng()*(H-4))|0);
      if (g[y][x] === 2) return {x,y};
    }
    // fallback : on en crée une petite au hasard
    return { x: (W/2)|0, y: (H/2)|0 };
  }

  for (let k=0; k<nPlac; k++){
    const seed = pickOpen();
    const hx = Math.max(halfMin, Math.min(halfMax, (halfMin + ((rng()*(halfMax-halfMin+1))|0)) ));
    const hy = Math.max(halfMin, Math.min(halfMax, (halfMin + ((rng()*(halfMax-halfMin+1))|0)) ));

    // centre légèrement bruité depuis la seed
    const cx = Math.max(2, Math.min(W-3, seed.x + (((rng()*3)|0)-1) ));
    const cy = Math.max(2, Math.min(H-3, seed.y + (((rng()*3)|0)-1) ));

    // on ouvre un rectangle (cx-hx..cx+hx , cy-hy..cy+hy)
    for (let y=cy-hy; y<=cy+hy; y++){
      for (let x=cx-hx; x<=cx+hx; x++){
        open(x,y);
      }
    }

    // petite “respiration” vers l’extérieur pour éviter les salles trop fermées
    open(cx-hx-1, cy); open(cx+hx+1, cy);
    open(cx, cy-hy-1); open(cx, cy+hy+1);

    // éventuellement arrondir un peu les coins (option doux)
    if (rng() < 0.5) open(cx-hx, cy-hy-1);
    if (rng() < 0.5) open(cx+hx, cy-hy-1);
    if (rng() < 0.5) open(cx-hx, cy+hy+1);
    if (rng() < 0.5) open(cx+hx, cy+hy+1);
  }

  return g;
}



/* ============ État jeu ============ */
const Game={
  preStart: false,
  started:false, mode:'solo',
  grid:null, remaining:0,
  score1:0, score2:0, lives1:3, lives2:3,
  paused:false, countdown:0,
  traps:[], bonuses:[], parasites:[], particles:[], vortexes:[], 
  muscariaTrap1:null, muscariaTrap2:null,
  p1:null, p2:null,
  servant1:null, servant2:null,
  blindGlobal:0,
  levelsToPlay: MATCH_LEVELS_SOLO,
  girollePanic:{active:false, ownerPid:0},
  showStartHint: 0,
  themeLayer:null, wallsLayer:null, pelletsLayer:null,
  floorLayer:null,
  sealWallFor: { 1: null, 2: null },
  vortexBlocks:[]
};

function gridDims(){ const rows=Array.isArray(Game.grid)?Game.grid.length:0; const cols=rows>0 && Array.isArray(Game.grid[0])?Game.grid[0].length:0; return {cols,rows}; }

function isCoopWithStropharia(){
  return Game.mode==='duo' &&
    ((Game.p1 && Game.p1.species.id==='stropharia') ||
     (Game.p2 && Game.p2.species.id==='stropharia'));
}
  

/* =================== VORTEX : placement proche des angles + carving =================== */

// Carve "croix" douce autour du vortex pour élargir légèrement le passage
function carvePlus(x, y) {
  const dm = gridDims(); const C=dm.cols, R=dm.rows;
  const open = (tx,ty)=>{
    if (tx>0 && ty>0 && tx<C-1 && ty<R-1) {
      if (Game.grid[ty][tx] === 1) Game.grid[ty][tx] = 2; // 2 = ouvert (spore)
    }
  };

  // anneau immédiat (3x3) — on n'ouvre PAS le centre, il restera VORTEX
  for (let dy=-1; dy<=1; dy++){
    for (let dx=-1; dx<=1; dx++){
      if (dx===0 && dy===0) continue; // centre = vortex
      open(x+dx, y+dy);
    }
  }

  // petite respiration supplémentaire sur les 4 axes
  open(x-2, y);
  open(x+2, y);
  open(x, y-2);
  open(x, y+2);
}

// Cherche une case ouverte proche d’un angle, sinon on “perce” un peu
function pickNearCorner(corner) {
  // corner: 'tl' | 'tr' | 'bl' | 'br'
  const dm = gridDims(); const C=dm.cols, R=dm.rows;
  const pad = Math.max(3, Math.floor(Math.min(C,R)*0.12)); // zone angulaire
  let x0 = (corner==='tl'||corner==='bl') ? 1 : Math.max(1, C-pad-1);
  let y0 = (corner==='tl'||corner==='tr') ? 1 : Math.max(1, R-pad-1);
  const x1 = (corner==='tl'||corner==='bl') ? Math.min(C-2, 1+pad) : C-2;
  const y1 = (corner==='tl'||corner==='tr') ? Math.min(R-2, 1+pad) : R-2;

  // 1) tente une case déjà ouverte (2)
  for (let tries=0; tries<400; tries++){
    const x = x0 + ((Math.random()*(x1-x0+1))|0);
    const y = y0 + ((Math.random()*(y1-y0+1))|0);
    if (Game.grid[y] && Game.grid[y][x]===2) return {x,y};
  }
  // 2) sinon, on perce légèrement depuis la bordure vers l’intérieur
  for (let tries=0; tries<400; tries++){
    const x = x0 + ((Math.random()*(x1-x0+1))|0);
    const y = y0 + ((Math.random()*(y1-y0+1))|0);
    if (Game.grid[y] && Game.grid[y][x]===1) {
      // Perce uniquement si un voisin est ouvert, pour rester connecté
      if (Game.grid[y][x-1]===2 || Game.grid[y][x+1]===2 || Game.grid[y-1]?.[x]===2 || Game.grid[y+1]?.[x]===2) {
        Game.grid[y][x]=2; // devient ouvert
        return {x,y};
      }
    }
  }
  // 3) fallback sûr
  return findOpenTile();
}

// Place 4 vortex (un par angle), marque la case comme VORTEX, élargit localement et stocke
function placeVortexes(){
  Game.vortexes = [];
  const corners = ['tl','tr','bl','br'];
  for (const c of corners){
    const pos = pickNearCorner(c);
    // centre = vortex (pas de spore)
    Game.grid[pos.y][pos.x] = VORTEX;
    carvePlus(pos.x, pos.y);
    Game.vortexes.push({x:pos.x, y:pos.y});
  }
}

function randomOtherVortexIndex(fromIdx){
  if(!Array.isArray(Game.vortexes) || Game.vortexes.length<2) return fromIdx;
  let idx = fromIdx;
  while (idx===fromIdx) idx = (Math.random()*Game.vortexes.length)|0;
  return idx;
}

function teleportEntityToOtherVortex(entity, fromGX, fromGY){
  if(!Game.vortexes || Game.vortexes.length<2) return;
  let fromIdx = Game.vortexes.findIndex(v=>v.x===fromGX && v.y===fromGY);
  if(fromIdx<0) fromIdx = 0;
  const toIdx = randomOtherVortexIndex(fromIdx);
  const target = Game.vortexes[toIdx];
  
// Blocus 5s du vortex d'arrivée
addVortexBlock(target.x, target.y, 300);
  
  entity.x = target.x + 0.5;
  entity.y = target.y + 0.5;
  entity.dir = [0,0];

  // anti-boucle
  entity.tpGrace = 20; // ~0.33 s

  // si parasite (pas de pid) -> décale hors du vortex + évite 2 s
if (entity && typeof entity.pid !== 'number') {
  const opts = neighborsForParasite(target.x, target.y);
  if (opts.length){
    const pick = opts[(Math.random()*opts.length)|0];
    entity.x = pick[0] + 0.5;
    entity.y = pick[1] + 0.5;
  }
  entity.avoidVortex = 120; // ~2 s
}

  // --- AJOUT : si c'est un JOUEUR (possède pid), on déclenche spin + glow 2s
  if (entity && typeof entity.pid === 'number') {
    entity.spinTimer = 120; // 2s @60fps
    entity.glowTimer = 120;
  }

  // petit effet visuel
  Game.particles.push({x:(target.x*TILE), y:(target.y*TILE), r:0, life:120, type:'cloud'});
}
  
function resetMatch(full){
  full=!!full;
  Game.score1=0; Game.score2=0; Game.lives1=3; Game.lives2=3;
  LEVEL_INDEX=0;
  Game.levelsToPlay = 1;
  loadLevel(0,true);
  UI.mode.textContent=(Game.mode==='duo'?'2 Joueurs':'Solo');
  UI.p2hud.style.display=(Game.mode==='duo')?'':'none';
  Game.paused=true; Game.countdown=0;
  updateLeaderHUD();
}

function enemyBaseSpeedAt(levelIdx){
  // vitesse de base commune à l’init et au respawn
  return 0.09 + Math.min(0.1, levelIdx * 0.01);
}

function applySpeciesBaseSpeed(pl){
  const e = enemyBaseSpeedAt(LEVEL_INDEX);
  if (pl.species.id === 'stropharia'){
    pl.baseSpeed = e * 1.12;    // +12% ≈ "légèrement plus rapide"
  } else if (pl.species.id === 'anthurus'){
    pl.baseSpeed = e;           // identique aux parasites
  } else {
    pl.baseSpeed = 0.11;        // défaut
  }
  // conserve les buffs cumulés
  pl.speed = pl.baseSpeed * Math.pow(1.4, pl.speedBuffs || 0);
}
  
  
function loadLevel(i,first=false){
  BIOME=BIOMES[i%BIOMES.length];
const seed = (SESSION_SEEDS[i] ?? ((Math.random()*1e9)|0)) + (i*101);
Game.grid = genLevel(seed);
  placeVortexes();
  Game.traps=[]; Game.bonuses=[]; Game.parasites=[]; Game.particles=[];
  Game.muscariaTrap1=null; Game.muscariaTrap2=null; Game.remaining=0;
  Game.sealWallFor = { 1: null, 2: null };
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;

  for(let y=0;y<rows;y++){
    const row=Game.grid[y];
    for(let x=0;x<cols;x++){
      const v=row[x];
      if(v===2) Game.remaining++;
      if (v===3) {
  const k = (i + y + x) % BonusKinds.length;
  Game.bonuses.push({ x, y, kind: pickBonusKind(k) });
}
      if(v===4) Game.traps.push({x,y,t:(i+x+y)%2});
    }
  }

  const count= (6+Math.floor(i*0.8));
  for(let k=0;k<count;k++){
    const pos=findOpenTile();
const base = enemyBaseSpeedAt(i);
const speed = base * SelectedDifficulty.factor;
   Game.parasites.push({
  x: pos.x + 0.5,
  y: pos.y + 0.5,
  dir: [1, 0],
  speed: speed,
  baseSpeed: speed,

  // ← sprite parasite aléatoire (1..7)
  kind: ((Math.random() * 7) | 0) + 1,

  // --- ORIENTATION (quart de tour) ---
  faceAngle: angleFromDir4([1, 0]) || 0,
  turnFromAngle: 0,
  turnToAngle: 0,
  turnTimer: 0,
  turnDuration: 6,
  pendingAngle: null,

  scared: 0,
  blind: 0,
  state: 'wander',
  lastSeen: null,
  path: [],
  chaos: false,
  chaosMode: null,
  chaosTick: 0,
  chaosTarget: null,
  seedOnce: false,
  seedCd: 0,
  chaosAte: false,
  servant: false,
  frozen: 0,
  servantTime: 0,
  servantOwner: 0,

  // knockback
  kbActive: false,
  kbTx: 0,
  kbTy: 0,
  kbSpeed: 0,
  kbDir: [0, 0],

  // confusion (après impact mur)
  fleeGirolle: 0,
  morilleChaos: 0,
  morilleOwner: 0,
  morilleNextSwitch: 0,
  morilleMode: null,
  confusedTimer: 0,

  tpGrace: 0,
  avoidVortex: 0 // frames à éviter de repasser sur un vortex
});
  }

  // joueurs — positions de départ vraiment aléatoires
  const p1pos = findOpenTile();
  let p2pos = null;
  if (Game.mode==='duo'){
    // essaie d'éloigner les spawns (≈ la moitié de la petite dimension)
    const dm=gridDims();
    const minD = Math.max(6, Math.min(dm.cols, dm.rows)/2|0);
    p2pos = findOpenTileFarFrom(p1pos, minD);
  }

  if(first){
    Game.p1 = makePlayer(p1pos.x, p1pos.y, 1, Selected1);
    if(Game.mode==='duo'){ Game.p2 = makePlayer(p2pos.x, p2pos.y, 2, Selected2); }
  }else{
    Game.p1.x = p1pos.x+0.5; Game.p1.y = p1pos.y+0.5; Game.p1.dir=[0,0];
    if(Game.mode==='duo' && Game.p2){
      Game.p2.x = p2pos.x+0.5; Game.p2.y = p2pos.y+0.5; Game.p2.dir=[0,0];
    }
  }

if (Game.p1) applySpeciesBaseSpeed(Game.p1);
if (Game.mode==='duo' && Game.p2) applySpeciesBaseSpeed(Game.p2);


  // --- RESET des effets temporaires à chaque début de niveau
resetPlayerTransientForNewLevel(Game.p1);
if (Game.mode === 'duo' && Game.p2) resetPlayerTransientForNewLevel(Game.p2);

// Nettoie les libellés pouvoirs dans le HUD
UI.power1.textContent = '—';
if (Game.mode === 'duo') UI.power2.textContent = '—';

  buildLayers();
  UI.score1.textContent = Game.score1; UI.lives1.textContent = Game.lives1; UI.power1.textContent = '—';
  UI.score2.textContent = Game.score2; UI.lives2.textContent = Game.lives2; UI.power2.textContent = '—';
  UI.diff.textContent = SelectedDifficulty.name;
 Game.paused = true; 
Game.countdown = 0;
Game.preStart = true;      // ← signal “avant départ” actif

  updateLeaderHUD();
}

function makePlayer(tx,ty,pid,species){
  return {
    pid, species,
    x:tx+0.5, y:ty+0.5, dir:[0,0], nextDir:[0,0],
    // vitesses
    baseSpeed: 0.11,   // ← vitesse de référence
    speed: 0.11,       // ← vitesse courante (calculée)
    speedBuffs: 0,     // ← nb de buffs "speed" actifs en parallèle

    size:0.9,
    powerTimer:0, invisible:false, speedBoost:1, spinning:false, shield:false, phase:false,
    frozenTimer:0, anim:0, nextPowerExtend:0, girolleTrapImmune:false, phaseCooldown:0, phaseInsideWall:false, hunterWindow:0, trumpetTrapImmune:false,
    respawnFlash: 0, hitGrace: 0, tpGrace: 0, spinTimer: 0, spinPhase: 0, glowTimer: 0, invulnTimer: 0, collectedSpores:0,
    trumpetCd:0, madnessTimer:0,
    panelActive:false,           // fenêtre latérale ouverte (immobile + rémap des touches)
    panelSel:0,                  // index en surbrillance dans la liste
    hiddenFromParasites:false,   // non-ciblable par l’IA parasite (ciblage)
    anthurusCharge:0,             // compte de spores mangées depuis la dernière activation
    superPowerHeld:false       // ← NOUVEAU : tient un bonus "power" en stock ?
  };
}

  // --- RESET ÉTATS TEMPORAIRES AU DÉBUT D'UN NOUVEAU NIVEAU ---
// (ne touche pas aux compteurs long-terme comme collectedSpores)
function resetPlayerTransientForNewLevel(pl){
  if(!pl) return;
  // Effets de pouvoir en cours
  pl.powerTimer = 0;
  pl.invisible  = false;
  pl.speedBoost = 1;
  pl.shield     = false;

  // Phalloïde
  pl.phase = false;
  pl.phaseInsideWall = false;
  pl.phaseCooldown   = 0;

  // Girolle
  pl.hunterWindow = 0;
  pl.invulnTimer  = 0;

  // Trompette
  pl.trumpetCd = 0;              // on remet le CD à 0 entre niveaux
  pl.trumpetTrapImmune = false;

  // Divers runtime
  pl.hitGrace = 0;
  pl.frozenTimer = 0;
  pl.respawnFlash = 0;
  pl.spinTimer = 0;
  pl.spinPhase = 0;
  pl.glowTimer = 0;
  pl.tpGrace = 0;
  pl.nextPowerExtend = 0;
  pl.speedBuffs = 0;
  pl.speed = pl.baseSpeed;
  pl.superPowerHeld = false;

  // IMPORTANT : on NE remet PAS pl.collectedSpores ici
}


function resetPlayerRuntimeState(pl){
  if(!pl) return;
  // états de pouvoir / temps
  pl.powerTimer = 0;
  pl.invisible  = false;
  pl.speedBoost = 1;
  pl.shield     = false;

  // Phalloïde
  pl.phase = false;
  pl.phaseInsideWall = false;
  pl.phaseCooldown   = 0;

  // Girolle
  pl.hunterWindow = 0;
  pl.invulnTimer  = 0;

  // Trompette
  pl.trumpetCd = 0;
  pl.trumpetTrapImmune = false;
  pl.collectedSpores   = 0;   // <<< durée potentielle = 0 s

  // Divers runtime
  pl.hitGrace = 0;
  pl.frozenTimer = 0;
  pl.respawnFlash = 0;
  pl.spinTimer = 0;
  pl.spinPhase = 0;
  pl.glowTimer = 0;
  pl.tpGrace = 0;
  pl.nextPowerExtend = 0;
  pl.speedBuffs = 0;
  pl.speed = pl.baseSpeed;
}
  

function findOpenTile(){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; for(let t=0;t<4000;t++){ const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0; if(Game.grid[y]&&Game.grid[y][x]===2) return {x,y}; } return {x:1,y:1}; }
function findOpenTileFarFrom(ref, minD){
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;
  const minDist = Math.max(2, minD|0);
  for(let t=0;t<4000;t++){
    const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0;
    if(Game.grid[y] && Game.grid[y][x]===2){
      const d = Math.abs(x-ref.x)+Math.abs(y-ref.y); // distance de Manhattan
      if(d>=minDist) return {x,y};
    }
  }
  return findOpenTile();
}
function findOpenNear(cx,cy){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; const maxR=Math.max(cols,rows); for(let r=0;r<maxR;r++){ for(let dy=-r;dy<=r;dy++){ for(let dx=-r;dx<=r;dx++){ const x=cx+dx,y=cy+dy; if(x>=1&&y>=1&&x<cols-1&&y<rows-1){ if(Game.grid[y]&&Game.grid[y][x]===2) return {x,y}; } } } } return findOpenTile(); }

// Téléporte un parasite sur la case ouverte la plus éloignée d'un joueur de référence
function teleportParasiteFarFromPlayer(parasite, plRef){
  const dm = gridDims();
  let best = null, bestD = -1;
  for (let y = 1; y < dm.rows - 1; y++){
    for (let x = 1; x < dm.cols - 1; x++){
      if (isWalkableForParasite(x, y)){
        const d = Math.hypot((x+0.5) - plRef.x, (y+0.5) - plRef.y);
        if (d > bestD){ bestD = d; best = [x, y]; }
      }
    }
  }
  if (best){
    parasite.x = best[0] + 0.5;
    parasite.y = best[1] + 0.5;
    parasite.dir = [0,0];
    parasite.path = [];
    parasite.lastSeen = null;
    parasite.tpGrace = 20;     // anti-boucle ~0.33s
    parasite.avoidVortex = 120; // évite les vortex 2s
  }
}
  
  
function spawnEnemy(){ const pos=findOpenTile(); const base = enemyBaseSpeedAt(LEVEL_INDEX);
const speed = base * SelectedDifficulty.factor; const kind=(Math.random()*4)|0;
  Game.parasites.push({
    x: pos.x + 0.5,
    y: pos.y + 0.5,
    dir: [1, 0],
    speed: speed,
    baseSpeed: speed,

    // --- Sprite parasite aléatoire : 1..7 ---
    kind: ((Math.random() * 7) | 0) + 1,

    // --- ORIENTATION (quart de tour sur changement de direction) ---
    faceAngle: (typeof angleFromDir4 === 'function' ? angleFromDir4([1,0]) : 0),
    turnFromAngle: 0,
    turnToAngle: 0,
    turnTimer: 0,
    turnDuration: 6,   // ~6 frames pour l'anim du quart de tour
    pendingAngle: null,

    scared: 0,
    blind: 0,
    state: 'wander',
    lastSeen: null,
    path: [],
    chaos: false,
    chaosMode: null,
    chaosTick: 0,
    chaosTarget: null,
    seedOnce: false,
    seedCd: 0,
    chaosAte: false,

    servant: false,
    frozen: 0,
    servantTime: 0,
    servantOwner: 0,

    // knockback
    kbActive: false,
    kbTx: 0,
    kbTy: 0,
    kbSpeed: 0,
    kbDir: [0, 0],

    // confusion (après impact mur)
    fleeGirolle: 0,
    morilleChaos: 0,
    morilleOwner: 0,
    morilleNextSwitch: 0,
    morilleMode: null,
    confusedTimer: 0,

    tpGrace: 0,
    avoidVortex: 0 // frames à éviter de repasser sur un vortex
  });
}

/* Bonus & spores */
const BonusKinds=['life','speed','power','score','freeze'];
  // --- Tuile vortex ---
const VORTEX = 5; // case spéciale vortex (walkable, sans spore)
function pickBonusKind(seed){ return BonusKinds[seed%BonusKinds.length]; }
function spawnSporeCloud(x,y,radTiles=null){
  Game.particles.push({x:x*TILE,y:y*TILE,r:0,life:240,type:'cloud'});
  if (radTiles!=null) {
    Game.parasites.forEach(p=>{
      if (Math.hypot(p.x-x, p.y-y) <= radTiles) p.scared = 200;
    });
  }
}


/* ---------- Repousse radial (fallback) ---------- */
function repelEnemiesAround(pl, radiusTiles, forceTiles){
  const radius = radiusTiles;
  const force  = forceTiles;
  const px = pl.x, py = pl.y;

  Game.parasites.forEach(p=>{
    const dx = p.x - px, dy = p.y - py;
    const dist = Math.hypot(dx,dy);
    if(dist > 0 && dist <= radius){
      const nx = dx / dist, ny = dy / dist;
      p.x += nx * force;
      p.y += ny * force;
      p.scared = Math.max(p.scared, 120);
      p.path = [];
      p.lastSeen = null;
    }
  });
}

/* ---------- Knockback (Cèpe) + effet domino ---------- */
// calcule la cible mur depuis p en suivant le vecteur depuis pl -> p
function computeKnockbackTarget(p, pl){
  let dx = p.x - pl.x, dy = p.y - pl.y;
  const len = Math.hypot(dx, dy) || 1;
  dx /= len; dy /= len;
  return computeKnockbackTargetDir({x:p.x, y:p.y}, [dx,dy]);
}
// calcule la cible mur depuis origin (obj {x,y} en cases) dans la direction dir ([dx,dy] normalisé)
function computeKnockbackTargetDir(origin, dir){
  const step = 0.2;
  const maxSteps = 220;
  let lastX = origin.x, lastY = origin.y;
  const dx = dir[0], dy = dir[1];
  for(let i=0;i<maxSteps;i++){
    const nx = lastX + dx * step;
    const ny = lastY + dy * step;
    const gx = Math.floor(nx), gy = Math.floor(ny);
    if(!isWalkable(gx, gy)){
      break; // le prochain pas tape un mur -> on s'arrête juste avant
    }
    lastX = nx; lastY = ny;
  }
  return { x:lastX, y:lastY };
}

// Construit le calque "sol" à partir de l'image 1024×1024
function buildFloorLayer(){
  const floor = makeLayerCanvas(W, H);
  const fctx = floor.getContext('2d');
  const img = loadImg('sol_foret.png'); // image à la racine

  const draw = () => {
    // Motif répété sur TOUT le canvas, y compris sous les murs
    const pat = fctx.createPattern(img, 'repeat');
    fctx.fillStyle = pat;
    fctx.fillRect(0, 0, W, H);

    Game.floorLayer = floor;
  };

  if (img.complete) draw();
  else img.addEventListener('load', draw, { once:true });
}

  
  
/* Couches graphiques */
function buildLayers(){
  const theme=makeLayerCanvas(W,H), tctx=theme.getContext('2d');
  const g=tctx.createLinearGradient(0,0,0,H); g.addColorStop(0,BIOME.sky1); g.addColorStop(1,BIOME.sky2);
  tctx.fillStyle=g; tctx.fillRect(0,0,W,H);
  for(let i=0;i<60;i++){ tctx.globalAlpha=0.08; tctx.beginPath(); tctx.arc(Math.random()*W,Math.random()*H,10+Math.random()*30,0,6.28); tctx.fillStyle=BIOME.fog; tctx.fill(); }
  Game.themeLayer=theme;
 // ← AJOUT : sol texturé
  buildFloorLayer();
 const walls=makeLayerCanvas(W,H), wctx=walls.getContext('2d');
  const pellets=makeLayerCanvas(W,H), pctx=pellets.getContext('2d');
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;
  for(let y=0;y<rows;y++){
    const row=Game.grid[y];
    for(let x=0;x<cols;x++){
      if(row[x]===1) drawWallCell(wctx,x,y);    // murs arbres (au premier plan)
      if(row[x]===2) drawPellet(pctx,x,y);
    }
  }
  Game.wallsLayer=walls; Game.pelletsLayer=pellets;
}
function drawWallCell(ctx, x, y) {
  const px = x * TILE, py = y * TILE;

  const path = pickTreeSpriteAt(x, y);
  const img  = loadImg(path);

  // On déborde de 1px de chaque côté : -1, +2
  const bleed = 1;
  const ox = px - bleed;
  const oy = py - bleed;
  const S  = TILE + bleed * 2;

  if (img.complete) {
    ctx.drawImage(img, ox, oy, S, S);
  } else {
    img.addEventListener('load', () => ctx.drawImage(img, ox, oy, S, S), { once:true });
  }
}



function drawPellet(ctx,x,y){ const px=x*TILE+TILE/2, py=y*TILE+TILE/2; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(px,py,3,0,6.28); ctx.fill(); }

/* =================== IA, GAMEPLAY & RENDU =================== */
function dims(){ const dm=gridDims(); return {C:dm.cols,R:dm.rows}; }
function openTile(tx,ty,pl){ const d=dims(); if(!Game.grid||ty<0||tx<0||ty>=d.R||tx>=d.C) return false; const v=Game.grid[ty][tx]; if(v===1){ if(pl&&pl.phase){ if(tx===0||ty===0||tx===d.C-1||ty===d.R-1) return false; return true; } return false; } if(v===VORTEX && isVortexBlocked(tx,ty)) return false; return true; }
function isWalkable(tx,ty){
  const d=dims();
  if(tx<0||ty<0||tx>=d.C||ty>=d.R) return false;
  const v = Game.grid[ty][tx];
  if(v===1) return false;
  if(v===VORTEX && isVortexBlocked(tx,ty)) return false;
  return true;
}
function neighbors(tx,ty){ return [[1,0],[-1,0],[0,1],[0,-1]].map(d=>[tx+d[0],ty+d[1]]).filter(p=>isWalkable(p[0],p[1])); }
function isVortex(tx, ty){
  return !!(Game.grid[ty] && Game.grid[ty][tx] === VORTEX);
}
function isVortexBlocked(tx, ty){
  return Game.vortexBlocks.some(b => b.x===tx && b.y===ty && b.timer>0);
}
function addVortexBlock(tx, ty, frames=300){
  // remplace si déjà présent
  const i = Game.vortexBlocks.findIndex(b=>b.x===tx && b.y===ty);
  if(i>=0) Game.vortexBlocks[i].timer = Math.max(Game.vortexBlocks[i].timer, frames);
  else Game.vortexBlocks.push({x:tx, y:ty, timer:frames});
}
function isWalkableForParasite(tx, ty){
  // Un parasite considère un vortex comme “mur mou” pour l’itinéraire
  return isWalkable(tx,ty) && !isVortex(tx,ty);
}
function neighborsForParasite(tx,ty){
  return [[1,0],[-1,0],[0,1],[0,-1]]
    .map(d=>[tx+d[0],ty+d[1]])
    .filter(p=>isWalkableForParasite(p[0],p[1]));
}

function getFacingDir(pl){
  if (pl && pl._lastDir && (pl._lastDir[0] || pl._lastDir[1])) return pl._lastDir.slice(0);
  if (pl && (pl.dir[0] || pl.dir[1])) return pl.dir.slice(0);
  if (pl && (pl.nextDir[0] || pl.nextDir[1])) return pl.nextDir.slice(0);
  return [0,-1]; // défaut: regarde vers le haut
}
function frontTile(pl){
  const d=getFacingDir(pl); return { tx: Math.floor(pl.x)+d[0], ty: Math.floor(pl.y)+d[1] };
}
function backTile(pl){
  const d=getFacingDir(pl); return { tx: Math.floor(pl.x)-d[0], ty: Math.floor(pl.y)-d[1] };
}
function isInterior(x,y){
  const dm=gridDims(); return (x>0 && y>0 && x<dm.cols-1 && y<dm.rows-1);
}
  

function addPelletCell(x,y){
  if(!Game.pelletsLayer) return;
  const pctx=Game.pelletsLayer.getContext('2d');
  drawPellet(pctx, x, y);
}

function clearWallCell(x,y){
  if(!Game.wallsLayer) return;
  const wctx=Game.wallsLayer.getContext('2d');
  wctx.clearRect(x*TILE, y*TILE, TILE, TILE);
}

function redrawWallIfAny(x,y){
  if(Game.grid[y][x]===1) drawWallCell(Game.wallsLayer.getContext('2d'), x,y);
  else clearWallCell(x,y);
}

function countReachableSporesFrom(gx,gy){
  const dm=gridDims(); const seen=new Set(); const q=[[gx,gy]];
  const key=(x,y)=>x+','+y;
  let count=0;
  while(q.length){
    const [x,y]=q.shift();
    const k=key(x,y); if(seen.has(k)) continue; seen.add(k);
    if(!isWalkable(x,y)) continue;
    if(Game.grid[y][x]===2) count++;
    neighbors(x,y).forEach(n=>{ q.push(n); });
  }
  return count;
}

// place un mur, annule si cela isole l’adversaire de TOUTES les spores restantes
function safeSetWallWithAntiSeal(x,y, oppPlayer){
  const prev = Game.grid[y][x];
  Game.grid[y][x] = 1;
  // Nettoie un éventuel bonus/piège avalé par le mur
const bi = Game.bonuses.findIndex(b=>b.x===x && b.y===y);
if (bi>=0) Game.bonuses.splice(bi,1);
const ti = Game.traps.findIndex(t=>t.x===x && t.y===y);
if (ti>=0) Game.traps.splice(ti,1);

  redrawWallIfAny(x,y);

  const oppGX = Math.floor(oppPlayer.x), oppGY = Math.floor(oppPlayer.y);
  const spores = countReachableSporesFrom(oppGX, oppGY);

  if (spores === 0){
    // Annulé → on restaure l’état visuel aussi
    Game.grid[y][x] = prev;
    redrawWallIfAny(x,y);
    if (prev === 2) addPelletCell(x,y);   // <<< Restaure le point lumineux
  }
}

function placeWallWithSealTracking(x, y, ownerPl, oppPl){
  // On ne suit que le cas Anthurus
  if (!ownerPl || ownerPl.species.id !== 'anthurus') {
    safeSetWallWithAntiSeal(x, y, oppPl);
    return;
  }
  // rien à faire si déjà un mur
  if (Game.grid[y][x] === 1) return;

  const before = countReachableSporesFrom(Math.floor(oppPl.x), Math.floor(oppPl.y));

  // Pose réelle (avec anti-seal total déjà en place)
  safeSetWallWithAntiSeal(x, y, oppPl);

  // Si la pose a été annulée, on sort
  if (Game.grid[y][x] !== 1) return;

  const after = countReachableSporesFrom(Math.floor(oppPl.x), Math.floor(oppPl.y));

  // Si on a réduit l’accès de l’adversaire (mais pas à zéro),
  // et qu’il reste des spores ailleurs sur la carte → on mémorise ce mur
  if (after > 0 && after < before && after < Game.remaining) {
    Game.sealWallFor[oppPl.pid] = { x, y };
  }
}

function autoUnsealIfRegionCleared(pl){
  if (!pl) return;

  // 1) avons-nous mémorisé un "mur de fermeture" pour ce joueur ?
  const rec = Game.sealWallFor[pl.pid];
  if (!rec) return;

  // 2) si le mur a déjà disparu (détruit manuellement ou regénération niveau), nettoyer l'état
  if (Game.grid[rec.y][rec.x] !== 1){
    Game.sealWallFor[pl.pid] = null;
    return;
  }

  // 3) combien de spores sont joignables depuis sa position actuelle ?
  const reachable = countReachableSporesFrom(Math.floor(pl.x), Math.floor(pl.y));

  // 4) déclencheur :
  //    - "reachable === 0" : sa zone fermée est désormais vide de spores
  //    - "Game.remaining > 0" : il reste des spores quelque part ailleurs sur la carte
  //      => on EST autorisé à rouvrir (sinon la condition serait vraie aussi en fin de niveau)
  if (reachable === 0 && Game.remaining > 0){
    // 5) on détruit UNIQUEMENT ce "dernier mur" — on ouvre en case VIDE (0)
    //    pour ne PAS manipuler Game.remaining (pas de nouvelle spore créée)
    Game.grid[rec.y][rec.x] = 0;

    // 6) mise à jour visuelle du calque des murs
    redrawWallIfAny(rec.x, rec.y); // efface le sprite (clearRect) car ce n'est plus un mur

    // 7) on oublie ce suivi (coup unique)
    Game.sealWallFor[pl.pid] = null;

    // 8) petit feedback audio facultatif
    sfxPower();
  }
}

  
function spawnTemporaryVortex(tx,ty,frames=600){
  const prev = Game.grid[ty][tx];

  // Retire et mémorise un éventuel item (bonus/piège) sur la case
  let savedBonus = null, savedTrap = null;
  const bi = Game.bonuses.findIndex(b=>b.x===tx && b.y===ty);
  if (bi>=0) savedBonus = Game.bonuses.splice(bi,1)[0];
  const ti = Game.traps.findIndex(t=>t.x===tx && t.y===ty);
  if (ti>=0) savedTrap = Game.traps.splice(ti,1)[0];

  Game.grid[ty][tx] = VORTEX;
  Game.vortexes.push({x:tx, y:ty, temp:true, expires:frames, restore:{prev, savedBonus, savedTrap}});
}


function disableNearbyTraps(cx,cy,rad=3){
  for(let i=Game.traps.length-1;i>=0;i--){
    const t=Game.traps[i];
    if (Math.hypot(t.x-cx, t.y-cy) <= rad){
      Game.grid[t.y][t.x]=0; Game.traps.splice(i,1);
    }
  }
  if(Game.muscariaTrap1 && Math.hypot(Game.muscariaTrap1.x-cx, Game.muscariaTrap1.y-cy)<=rad) Game.muscariaTrap1.active=false;
  if(Game.muscariaTrap2 && Math.hypot(Game.muscariaTrap2.x-cx, Game.muscariaTrap2.y-cy)<=rad) Game.muscariaTrap2.active=false;
}

  
function bfsParasite(start, goal){
  const key=(x,y)=>x+','+y;
  // Si la cible est un vortex, vise un voisin non-vortex
  if(isVortex(goal[0],goal[1])){
    const ns = neighborsForParasite(goal[0],goal[1]);
    if(ns.length) goal = ns[0];
  }
  if(!isWalkableForParasite(goal[0],goal[1])) return [];
  const q=[start];
  const came=new Map(); came.set(key(start[0],start[1]), null);
  while(q.length){
    const node=q.shift(); const x=node[0], y=node[1];
    if(x===goal[0]&&y===goal[1]) break;
    const ns=neighborsForParasite(x,y);
    for(let i=0;i<ns.length;i++){
      const nx=ns[i][0], ny=ns[i][1]; const k=key(nx,ny);
      if(!came.has(k)){ came.set(k,[x,y]); q.push([nx,ny]); }
    }
  }
  const path=[]; let cur=goal; const sKey=key(start[0],start[1]);
  while(cur && key(cur[0],cur[1])!==sKey){
    const prev=came.get(key(cur[0],cur[1])); if(!prev) break;
    path.push(cur); cur=prev;
  }
  path.reverse(); return path;
}

function tileCenter(gx, gy){ return [gx + 0.5, gy + 0.5]; }

function stepTowardsPoint(p, tx, ty, spd){
  const dx = tx - p.x, dy = ty - p.y, len = Math.hypot(dx,dy) || 1;
  p.x += (dx/len) * spd;
  p.y += (dy/len) * spd;
  p.dir = [Math.sign(dx), Math.sign(dy)];
}

function chaseViaPath(p, targetGX, targetGY, speedMul, dt){
  const eTile = [Math.floor(p.x), Math.floor(p.y)];
  // Chemin par tuiles (les parasites évitent les vortex)
  const path = bfsParasite(eTile, [targetGX, targetGY]);
  const base = p.speed * dt * (speedMul || 1);

  if (path && path.length){
    const nx = path[0][0], ny = path[0][1];
    const [tx, ty] = tileCenter(nx, ny);
    stepTowardsPoint(p, tx, ty, base);
    // si atteint le centre -> consomme l’étape
    if (Math.abs(p.x - tx) < 0.05 && Math.abs(p.y - ty) < 0.05){
      p.x = tx; p.y = ty;
      path.shift();
    }
    // mémorise le chemin restant
    p.path = path;
  } else {
    // Pas de chemin : petit déplacement au hasard mais RESTANT DANS LE WALKABLE
    const opts = neighborsForParasite(eTile[0], eTile[1]);
    if (opts.length){
      const [gx, gy] = opts[(Math.random()*opts.length)|0];
      const [tx, ty] = tileCenter(gx, gy);
      stepTowardsPoint(p, tx, ty, base * 0.9);
    }
  }
}

function safeClampParasite(p){
  const gx = Math.floor(p.x), gy = Math.floor(p.y);
  if (!isWalkableForParasite(gx, gy)){
    const near = findOpenNear(gx, gy);   // ta fonction existe déjà
    p.x = near.x + 0.5;
    p.y = near.y + 0.5;
    p.dir = [0,0];
    p.path = [];
    p.lastSeen = null;
  }
}

  
function bfs(start,goal){ const key=(x,y)=>x+','+y; if(!isWalkable(goal[0],goal[1])) return []; const q=[start]; const came=new Map(); came.set(key(start[0],start[1]), null); while(q.length){ const node=q.shift(); const x=node[0], y=node[1]; if(x===goal[0]&&y===goal[1]) break; const ns=neighbors(x,y); for(let i=0;i<ns.length;i++){ const nx=ns[i][0], ny=ns[i][1]; const k=key(nx,ny); if(!came.has(k)){ came.set(k,[x,y]); q.push([nx,ny]); } } } const path=[]; let cur=goal; const sKey=key(start[0],start[1]); while(cur && key(cur[0],cur[1])!==sKey){ const prev=came.get(key(cur[0],cur[1])); if(!prev) break; path.push(cur); cur=prev; } path.reverse(); return path; }
function sameRowOrCol(a,b){ return a[0]===b[0] || a[1]===b[1]; }
function hasLineOfSight(a,b){ if(!sameRowOrCol(a,b)) return false; const ax=a[0], ay=a[1], bx=b[0], by=b[1]; if(ax===bx){ const min=Math.min(ay,by), max=Math.max(ay,by); for(let y=min+1;y<max;y++){ if(Game.grid[y][ax]===1) return false; } return true; } else { const min=Math.min(ax,bx), max=Math.max(ax,bx); for(let x=min+1;x<max;x++){ if(Game.grid[ay][x]===1) return false; } return true; } }
function randomOpenTile(){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; for(let t=0;t<2000;t++){ const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0; if(isWalkable(x,y)) return [x,y]; } return [1,1]; }
function findNearestPellet(from){
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows; let best=null, bestD=1e9;
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){
    if(Game.grid[y][x]===2){ const d=Math.abs(x-from[0])+Math.abs(y-from[1]); if(d<bestD){ bestD=d; best=[x,y]; } }
  } return best;
}

/* Serviteur Girolle */
function convertToServant(p, ownerPid){
  p.servant=true; p.servantTime=900; p.servantOwner=ownerPid;
  p.scared=0; p.blind=0; p.path=[]; p.lastSeen=null; p.chaos=false; p.chaosMode=null; p.chaosTarget=null;
  if(ownerPid===1) Game.servant1=p; else Game.servant2=p;
}
function releaseServant(ownerPid){
  const s = ownerPid===1? Game.servant1 : Game.servant2;
  if(s){ s.servant=false; s.servantTime=0; s.servantOwner=0; if(ownerPid===1) Game.servant1=null; else Game.servant2=null; }
}

/* Bonus */
function eatBonusFor(player,b){
  // Par défaut on ne retire pas de la map tant qu'on n'a pas consommé
  let consumed = false;
  const clearCell = () => { Game.grid[b.y][b.x] = 0; consumed = true; };

  switch(b.kind){
    case 'life':
      clearCell();
      if(player.pid===1){ Game.lives1++; UI.lives1.textContent=Game.lives1; }
      else { Game.lives2++; UI.lives2.textContent=Game.lives2; }
      sfxLife();
      break;

    case 'speed': {
      clearCell();
      const mult = 1.4, dur = 6000;
      if (player.baseSpeed == null) player.baseSpeed = player.speed || 0.11;
      if (player.speedBuffs == null) player.speedBuffs = 0;
      player.speedBuffs += 1;
      player.speed = player.baseSpeed * Math.pow(mult, player.speedBuffs);
      sfxPower();
      setTimeout(() => {
        player.speedBuffs = Math.max(0, (player.speedBuffs || 0) - 1);
        player.speed = player.baseSpeed * Math.pow(mult, player.speedBuffs);
      }, dur);
      break;
    }

    case 'power': {
      // NON-CUMULABLE : si le joueur a déjà un power en poche, on ne ramasse pas.
      if (player.superPowerHeld) {
        // rien : le bonus reste au sol
      } else {
        clearCell();
        player.superPowerHeld = true;                       // on le met en poche
        (player.pid===1?UI.power1:UI.power2).textContent = '★ en poche';
        sfxPower();
      }
      break;
    }

    case 'score':
      clearCell();
      if(player.pid===1){ Game.score1+=500; UI.score1.textContent=Game.score1; }
      else { Game.score2+=500; UI.score2.textContent=Game.score2; }
      updateLeaderHUD(); sfxPower();
      break;

    case 'freeze':
      clearCell();
      Game.parasites.forEach(p => { p.frozen = Math.max(p.frozen||0, 180); });
      sfxPower();
      break;
  }
  return consumed; // ← indique si l’objet doit être retiré de la map
}

function refreshPelletCell(x,y){ if(!Game.pelletsLayer) return; const pctx=Game.pelletsLayer.getContext('2d'); pctx.clearRect(x*TILE,y*TILE,TILE,TILE); }

/* Entrées direction */
function inputDirFor(pid){
  if(pid===1){
    if(Keys['arrowup']) return [0,-1];
    if(Keys['arrowdown']) return [0,1];
    if(Keys['arrowleft']) return [-1,0];
    if(Keys['arrowright']) return [1,0];
  } else {
    if(Keys['z']) return [0,-1];
    if(Keys['s']) return [0,1];
    if(Keys['q']) return [-1,0];
    if(Keys['d']) return [1,0];
  }
  return [0,0];
}

  function inputDirForPlayer(pl){
  const inv = !!(pl && pl.madnessTimer > 0);
      if (pl && pl.panelActive) return [0,0];
  if(pl.pid===1){
    // J1: flèches
    if(Keys['arrowup'])    return inv ? [0,  1] : [0,-1];
    if(Keys['arrowdown'])  return inv ? [0, -1] : [0, 1];
    if(Keys['arrowleft'])  return inv ? [1,  0] : [-1,0];
    if(Keys['arrowright']) return inv ? [-1, 0] : [1, 0];
  } else {
    // J2: ZQSD
    if(Keys['z']) return inv ? [0,  1] : [0,-1];
    if(Keys['s']) return inv ? [0, -1] : [0, 1];
    if(Keys['q']) return inv ? [1,  0] : [-1,0];
    if(Keys['d']) return inv ? [-1, 0] : [1, 0];
  }
  return [0,0];
}


/* Boucle principale */
let LAST=now();
function loop(){
  const t=now(); const dt=(t-LAST)/16.666; LAST=t;
  if(Game.countdown>0) updateCountdown();
  if(!Game.paused && Game.countdown===0) update(dt);
  draw();
  requestAnimationFrame(loop);
}
function startCountdown(frames){
  Game.countdown = Math.max(1, frames|0);
  Game.paused = false;
  Game.preStart = false;   // ← on quitte l’état “avant départ”
}

function updateCountdown(){
  Game.countdown--;
  if(Game.countdown<=0){
    Game.countdown=0;
    // --- AJOUT : lueur 2s pour le(s) joueur(s)
    if(Game.p1) Game.p1.glowTimer = Math.max(Game.p1.glowTimer||0, 120);
    if(Game.mode==='duo' && Game.p2) Game.p2.glowTimer = Math.max(Game.p2.glowTimer||0, 120);
  }
}


/* Update */
function update(dt){
  if(!Game.grid) return;

  updatePlayer(Game.p1, dt);
  if(Game.mode==='duo' && Game.p2) updatePlayer(Game.p2, dt);

  // Parasites
Game.parasites.forEach((p,idx)=>{
  // ⇨ MAJ orientation (quart de tour) en début de tick
  updateParasiteOrientation(p, dt);

  if (p.tpGrace>0) p.tpGrace--;
  if (p.avoidVortex>0) p.avoidVortex--;

  // --- Gel global (freeze bonus) : immobile mais toujours dangereux si on le touche
  if (p.frozen > 0) {
    p.frozen--;
    // pas de déplacement ni d'IA, mais on conserve le check de collision:
    safeClampParasite(p)
    parasiteHitPlayers(p);
          // ⇨ Optionnel : synchronise la rotation pendant le knockback
      updateParasiteOrientation(p, dt);
    return;
  }


    // ---------- Knockback prioritaire + effet domino ----------
    if(p.kbActive){
      const dx = p.kbTx - p.x;
      const dy = p.kbTy - p.y;
      const dist = Math.hypot(dx, dy);
      const nx = (dist>0? dx/dist : 0), ny = (dist>0? dy/dist : 0);
      const spd = (p.kbSpeed || 0.22) * dt;
      p.kbDir = [nx,ny];
      if(dist <= 0.05){
        // Arrivé au mur -> confusion 3 s
        p.x = p.kbTx; p.y = p.kbTy;
        p.kbActive = false;
        p.confusedTimer = Math.max(p.confusedTimer, 180);
      } else {
        p.x += nx * spd;
        p.y += ny * spd;
        p.dir = [Math.sign(nx), Math.sign(ny)];

        // Collision avec d'autres parasites -> propulsion en ligne droite
        for(let j=0;j<Game.parasites.length;j++){
          if(j===idx) continue;
          const q = Game.parasites[j];
          if(q.kbActive || q.servant) continue;
          if(distance(p.x,p.y,q.x,q.y) < 0.55){
            // Propel q dans la même direction que p
            const tgt = computeKnockbackTargetDir(q, p.kbDir);
            q.kbActive = true;
            q.kbTx = tgt.x; q.kbTy = tgt.y;
            q.kbSpeed = Math.max(p.kbSpeed, q.speed*2);
            q.kbDir = [p.kbDir[0], p.kbDir[1]];
            q.path = []; q.lastSeen = null;
            q.scared = Math.max(q.scared, 90);
          }
        }
      }
      safeClampParasite(p)
      parasiteHitPlayers(p);
      return; // tant que knockback actif
    }

    // Confusion (après impact mur)
    if(p.confusedTimer>0){
      p.confusedTimer--;
      const eff = p.speed * dt * 0.4; // lent
      // petit erratisme
      if(Math.random()<0.25){
        const opts = neighborsForParasite(Math.floor(p.x), Math.floor(p.y));
        if(opts.length){
          const d=opts[(Math.random()*opts.length)|0];
          p.path = [[Math.floor(p.x)+d[0], Math.floor(p.y)+d[1]]];
        }
      }
      if(p.path && p.path.length){
        const tx=p.path[0][0]+0.5, ty=p.path[0][1]+0.5;
        const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
        p.x+=(dx/len)*eff; p.y+=(dy/len)*eff; p.dir=[Math.sign(dx),Math.sign(dy)];
        if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05) p.path.shift();
      }
      safeClampParasite(p)
      parasiteHitPlayers(p);
      return;
    }

    if(p.scared>0) p.scared--;
    if(p.blind>0) p.blind--;
    const eTile=[Math.max(0,Math.floor(p.x)), Math.max(0,Math.floor(p.y))];

// --- VORTEX : téléportation parasite ---
if (Game.grid[eTile[1]] && Game.grid[eTile[1]][eTile[0]] === VORTEX && !isVortexBlocked(eTile[0], eTile[1])) {
  if (!p.kbActive && p.tpGrace<=0) {
    teleportEntityToOtherVortex(p, eTile[0], eTile[1]);
    p.path=[]; p.lastSeen=null; // reset chemin
    return; // on ressort : la fonction de TP nous a déjà replacés
  }
  // Si on est dessus pendant la tpGrace, on “glisse” immédiatement sur un voisin non-vortex
  if (p.tpGrace>0) {
    const opts = neighborsForParasite(eTile[0], eTile[1]);
    if (opts.length){
      const [nx,ny] = opts[(Math.random()*opts.length)|0];
      const tx = nx+0.5, ty = ny+0.5;
      const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
      const spd = p.speed * dt * 1.2;
      p.x += (dx/len)*spd; p.y += (dy/len)*spd;
      p.dir=[Math.sign(dx),Math.sign(dy)];
      return;
    }
  }
}


    // pièges Amanite (si non serviteur)
    if(!p.servant){
      if(Game.muscariaTrap1 && Game.muscariaTrap1.active && eTile[0]===Game.muscariaTrap1.x && eTile[1]===Game.muscariaTrap1.y){
        const rt=randomOpenTile(); p.x=rt[0]+0.5; p.y=rt[1]+0.5; p.path=[]; p.lastSeen=null; p.chaosTarget=null;
      }
      if(Game.muscariaTrap2 && Game.muscariaTrap2.active && eTile[0]===Game.muscariaTrap2.x && eTile[1]===Game.muscariaTrap2.y){
        const rt=randomOpenTile(); p.x=rt[0]+0.5; p.y=rt[1]+0.5; p.path=[]; p.lastSeen=null; p.chaosTarget=null;
      }
    }

    // Fuite spécifique quand la Girolle a activé son pouvoir
if (Game.girollePanic.active && p.fleeGirolle > 0 && !p.servant) {
  p.fleeGirolle--;

  const owner = (Game.girollePanic.ownerPid === 1) ? Game.p1 : Game.p2;
  if (owner) {
    const eTile = [Math.floor(p.x), Math.floor(p.y)];
    let best = eTile, bestScore = -1;
    const ns = neighborsForParasite(eTile[0], eTile[1]);
    for (let i=0;i<ns.length;i++){
      const nx = ns[i][0], ny = ns[i][1];
      const dist = Math.hypot((nx+0.5)-owner.x, (ny+0.5)-owner.y);
      if (dist > bestScore) { bestScore = dist; best = ns[i]; }
    }
    const tx = best[0] + 0.5, ty = best[1] + 0.5;
    const dx = tx - p.x, dy = ty - p.y, len = Math.hypot(dx,dy)||1;
    const spd = p.speed * dt * 0.95;
    p.x += (dx/len)*spd; p.y += (dy/len)*spd;
    p.dir = [Math.sign(dx), Math.sign(dy)];
  }

  safeClampParasite(p)
  parasiteHitPlayers(p);
  return; // on court-circuite les autres IA (serviteur/aveugle/chaos/normal)
}

// --- CHAOS Morille (local et cadencé) ---
if (p.morilleChaos > 0) {
  p.morilleChaos--;
  p.morilleNextSwitch = (p.morilleNextSwitch||0) - 1;
  if (p.morilleNextSwitch <= 0 || !p.morilleMode) {
    // toutes les 5s (300 frames)
    p.morilleNextSwitch = 300;
    const modes = ['freeze','bounce','huntParasite','collect','rushPlayer'];
    p.morilleMode = modes[(Math.random()*modes.length)|0];
    p.chaosTarget = null;
  }

  const eTile=[Math.floor(p.x),Math.floor(p.y)];
  const base = p.speed*dt;
  const stepTo=(gx,gy,spd)=>{
    const tx=gx+0.5, ty=gy+0.5; const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
    p.x+=(dx/len)*spd; p.y+=(dy/len)*spd; p.dir=[Math.sign(dx),Math.sign(dy)];
    return (Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05);
  };

  if (p.morilleMode==='freeze') {
    // immobile
  }
  else if (p.morilleMode==='bounce') {
    // petits aller-retours
    if(!p.chaosTarget){
      const opts=[[1,0],[-1,0],[0,1],[0,-1]].filter(d=>isWalkable(eTile[0]+d[0], eTile[1]+d[1]));
      p.chaosTarget = opts.length ? [eTile[0]+opts[0][0], eTile[1]+opts[0][1]] : [eTile[0],eTile[1]];
    }
    const reached=stepTo(p.chaosTarget[0],p.chaosTarget[1], base*0.9);
    if(reached){
      const ox=eTile[0], oy=eTile[1];
      p.chaosTarget=[ox*2-p.chaosTarget[0], oy*2-p.chaosTarget[1]];
      if(!isWalkable(p.chaosTarget[0], p.chaosTarget[1])) p.chaosTarget=[ox,oy];
    }
  }
  else if (p.morilleMode==='huntParasite') {
  // cible : parasite le plus proche (hors soi)
  let targetQ = null, best = 1e9;
  for (const q of Game.parasites){
    if (q === p) continue;
    const d = Math.hypot(q.x - p.x, q.y - p.y);
    if (d < best){ best = d; targetQ = q; }
  }
  if (targetQ){
    const tgx = Math.floor(targetQ.x), tgy = Math.floor(targetQ.y);
    // Déplacement via BFS (x1.2 la vitesse)
    chaseViaPath(p, tgx, tgy, 1.2, dt);

    // Si contact proche, on déclenche un knockbackSUR la base du vecteur (mais on calcule la cible mur via helper)
    if (distance(p.x, p.y, targetQ.x, targetQ.y) < 0.6){
      const tgt = computeKnockbackTargetDir(targetQ, [targetQ.x - p.x, targetQ.y - p.y]);
      targetQ.kbActive = true;
      targetQ.kbTx = tgt.x;
      targetQ.kbTy = tgt.y;
      targetQ.kbSpeed = Math.max(targetQ.speed*2, 0.22);
      targetQ.kbDir = [Math.sign(tgt.x - targetQ.x), Math.sign(tgt.y - targetQ.y)];
    }
  }
}
  else if (p.morilleMode==='collect') {
  const eTile = [Math.floor(p.x), Math.floor(p.y)];
  const target = findNearestPellet(eTile);
  if (target){
    const [tgx, tgy] = target;
    // BFS (x1.05 la vitesse)
    chaseViaPath(p, tgx, tgy, 1.05, dt);

    // Si atteint, on ramasse proprement (en vérifiant la tuile)
    if (Math.floor(p.x) === tgx && Math.floor(p.y) === tgy){
      if (Game.grid[tgy] && Game.grid[tgy][tgx] === 2){
        Game.grid[tgy][tgx] = 0; Game.remaining--; sfxEat(); refreshPelletCell(tgx, tgy);
        if (p.morilleOwner === 1){ Game.score1 += 10; UI.score1.textContent = Game.score1; }
        else if (p.morilleOwner === 2){ Game.score2 += 10; UI.score2.textContent = Game.score2; }
        updateLeaderHUD();
      }
    }
  }
}

else if (p.morilleMode==='rushPlayer' && Game.mode==='duo') {
  const tgtPl = (p.morilleOwner===1)? Game.p2 : Game.p1;
  if (tgtPl){
    const tgx = Math.floor(tgtPl.x), tgy = Math.floor(tgtPl.y);
    // BFS avec vitesse x3
    chaseViaPath(p, tgx, tgy, 3.0, dt);
  }
}

  safeClampParasite(p)
  parasiteHitPlayers(p);
  return; // court-circuite le reste de l'IA pour ce parasite
}
    
    // Serviteur : collecte
    if(p.servant){
      p.servantTime--; if(p.servantTime<=0){ p.servant=false; if(p.servantOwner===1 && Game.servant1===p) Game.servant1=null; if(p.servantOwner===2 && Game.servant2===p) Game.servant2=null; }
      const target=findNearestPellet([Math.floor(p.x),Math.floor(p.y)]);
      const effspd=p.speed*dt*1.05;
      if(target){
        const tx=target[0]+0.5, ty=target[1]+0.5;
        const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
        p.x+=(dx/len)*effspd; p.y+=(dy/len)*effspd; p.dir=[Math.sign(dx),Math.sign(dy)];
        if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05){
          const gx=target[0], gy=target[1];
          if(Game.grid[gy] && Game.grid[gy][gx]===2){
            Game.grid[gy][gx]=0; Game.remaining--; sfxEat(); refreshPelletCell(gx,gy);
            if(p.servantOwner===1){ Game.score1+=10; UI.score1.textContent=Game.score1; } else if(p.servantOwner===2){ Game.score2+=10; UI.score2.textContent=Game.score2; }
            updateLeaderHUD();
          }
        }
      }
      safeClampParasite(p)
      parasiteHitPlayers(p);
      return;
    }

    // Aveugle : errance lente
if(p.blind>0){
  const eff=p.speed*dt*0.25; // très lent
  // direction aléatoire plus fréquente
  if(!p.path || p.path.length===0 || Math.random()<0.45){
    const opts = neighborsForParasite(eTile[0], eTile[1]);
    if (opts.length) {
  const id = (Math.random()*opts.length)|0;
  p.path = [[eTile[0]+opts[id][0], eTile[1]+opts[id][1]]];
} else {
  p.path = [];
}
  }
  if(p.path && p.path.length){
    const tx=p.path[0][0]+0.5, ty=p.path[0][1]+0.5;
    const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
    p.x+=(dx/len)*eff; p.y+=(dy/len)*eff; p.dir=[Math.sign(dx),Math.sign(dy)];
    if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05) p.path.shift();
  }
  safeClampParasite(p)
  parasiteHitPlayers(p);
  return;
}

// Fuite locale du Strophaire : si proche, on s'éloigne prioritairement
const stroph = (Game.p1 && Game.p1.species.id==='stropharia') ? Game.p1
              : (Game.mode==='duo' && Game.p2 && Game.p2.species.id==='stropharia' ? Game.p2 : null);
if (stroph){
  const distS = Math.hypot(p.x - stroph.x, p.y - stroph.y);
  if (distS <= 7 && !p.servant){ // rayon ≈ 7 cases
    const here = [Math.floor(p.x), Math.floor(p.y)];
    const ns = neighborsForParasite(here[0], here[1]);
    if (ns.length){
      // choisit le voisin qui maximise la distance au Strophaire
      let best = ns[0], bestScore = -1;
      for (const cand of ns){
        const d = Math.hypot((cand[0]+0.5)-stroph.x, (cand[1]+0.5)-stroph.y);
        if (d > bestScore){ bestScore = d; best = cand; }
      }
      const tx = best[0] + 0.5, ty = best[1] + 0.5;
      const dx = tx - p.x, dy = ty - p.y, len = Math.hypot(dx,dy) || 1;
      const spd = p.speed * dt * 0.95;
      p.x += (dx/len)*spd; p.y += (dy/len)*spd;
      p.dir = [Math.sign(dx), Math.sign(dy)];
      safeClampParasite(p);
      parasiteHitPlayers(p);
      return; // on court-circuite le mode normal ce tick
    }
  }
}

    
   // normal
    p.chaos=false; p.chaosMode=null; p.chaosTarget=null;

    // cible : joueur visible le plus proche/aligné
    const p1=Game.p1, p2=(Game.mode==='duo'?Game.p2:null);
    const eTile1=[Math.floor(p1.x),Math.floor(p1.y)];
    let target=null;
const sees1 = !p1.invisible && (p1.species.id!=='anthurus') &&
              (hasLineOfSight(eTile, eTile1) || (Math.abs(eTile[0]-eTile1[0])+Math.abs(eTile[1]-eTile1[1])<=6));
    if(sees1) target=eTile1;
    if(p2 && !p2.invisible){
      const eTile2=[Math.floor(p2.x),Math.floor(p2.y)];
const sees2 = (p2 && !p2.invisible && (p2.species.id!=='anthurus')) &&
              (hasLineOfSight(eTile, eTile2) || (Math.abs(eTile[0]-eTile2[0])+Math.abs(eTile[1]-eTile2[1])<=6));
      if(sees2){
        const d1=target? (Math.abs(eTile[0]-target[0])+Math.abs(eTile[1]-target[1])) : 1e9;
        const d2= Math.abs(eTile[0]-eTile2[0])+Math.abs(eTile[1]-eTile2[1]);
        if(d2<d1) target=eTile2;
      }
    }

if (target) {
  p.state = 'chase';
  p.lastSeen = [target[0], target[1]];
  p.path = bfsParasite(eTile, target);
} else if (p.lastSeen) {
  if (eTile[0] === p.lastSeen[0] && eTile[1] === p.lastSeen[1]) {
    p.lastSeen = null;
    p.state = 'search';
    p.target = randomOpenTile();
    p.path = bfsParasite(eTile, p.target);
  } else {
    p.state = 'search';
    p.path = bfsParasite(eTile, p.lastSeen);
  }
} else {
  if (!p.path || p.path.length === 0) {
    p.state = 'wander';
    p.target = randomOpenTile();
    p.path = bfsParasite(eTile, p.target);
  }
}

// Fallback : s'il n'y a toujours aucun chemin, avancer vers un voisin valable (hors vortex)
if (!p.path || p.path.length === 0) {
  const opts = neighborsForParasite(eTile[0], eTile[1]);
  if (opts.length) {
    const [nx, ny] = opts[(Math.random() * opts.length) | 0];
    p.path = [[nx, ny]];
  }
}

    const spd=p.speed*dt;
    if(p.path && p.path.length){
      const tx=p.path[0][0], ty=p.path[0][1];
      const targetX=tx+0.5, targetY=ty+0.5;
      const dx=targetX-p.x, dy=targetY-p.y, len=Math.hypot(dx,dy)||1;
      p.x += (dx/len)*spd; p.y += (dy/len)*spd; p.dir=[Math.sign(dx), Math.sign(dy)];
      if(Math.abs(p.x-targetX)<0.05 && Math.abs(p.y-targetY)<0.05){ p.x=targetX; p.y=targetY; p.path.shift(); }
    }
    safeClampParasite(p)
    parasiteHitPlayers(p);
  });

  // Particules
  for(let i=Game.particles.length-1;i>=0;i--){
    const pa=Game.particles[i];
    if(pa.type==='cloud'){ pa.r+=2*dt; pa.life-=1*dt; if(pa.life<=0) Game.particles.splice(i,1); }
  }

// Vortex blocks timers
for(let i=Game.vortexBlocks.length-1;i>=0;i--){
  Game.vortexBlocks[i].timer -= 1*dt;
  if(Game.vortexBlocks[i].timer<=0) Game.vortexBlocks.splice(i,1);
}

// === VORTEX TEMPORAIRES : décrémente et supprime à expiration ===
for (let i = Game.vortexes.length - 1; i >= 0; i--){
  const v = Game.vortexes[i];
  if (v && v.temp){
    v.expires -= 1*dt;
    if (v.expires <= 0){
      const r = v.restore || {prev:2};
      // 1) Restaure la tuile d'origine
      Game.grid[v.y][v.x] = (r.prev != null ? r.prev : 2);

      // 2) Si c'était une spore, redessine-la
      if (Game.grid[v.y][v.x] === 2) addPelletCell(v.x, v.y);

      // 3) Restaure bonus/piège s'ils existaient
      if (r.savedBonus) Game.bonuses.push(r.savedBonus);
      if (r.savedTrap)  Game.traps.push(r.savedTrap);

      // 4) Retire le vortex temporaire
      Game.vortexes.splice(i, 1);
    }
  }
}


if (Game.mode === 'duo') anthurusCatchCheck();
// --- AUTO-UNSEAL : si la zone fermée d'un joueur est vidée, on casse le dernier mur
autoUnsealIfRegionCleared(Game.p1);
if (Game.mode === 'duo' && Game.p2) autoUnsealIfRegionCleared(Game.p2);

  
// Fin de niveau / match
if (Game.remaining <= 0) {
  sfxWin();
if (Game.mode === 'duo') {
  const coop = isCoopWithStropharia();
  const p1Alive = Game.lives1 >= 0;
  const p2Alive = Game.lives2 >= 0;

  if (coop){
    if (p1Alive && p2Alive){
      const teamScore = Math.max(Game.score1, Game.score2);
      Game.score1 = teamScore; UI.score1.textContent = Game.score1;
      Game.score2 = teamScore; UI.score2.textContent = Game.score2;
      updateLeaderHUD();
      endMatch('Victoire coopérative !');
      return;
    } else {
      endMatch('Défaite — vous perdez ensemble');
      return;
    }
  }

  // mode compétitif (inchangé)
  if (p1Alive && p2Alive) {
    if (Game.score1 > Game.score2) { endMatch('Fin — J1 gagne au score !'); return; }
    if (Game.score2 > Game.score1) { endMatch('Fin — J2 gagne au score !'); return; }
    endMatch('Fin — Égalité parfaite !'); return;
  }
  endMatch('Fin — Partie terminée');
  return;
}


  // SOLO : une seule carte -> fin simple
  endMatch('Victoire !');
  return;
}

}

function parasiteHitPlayers(p){
  // --- Test J1 ---
  if (distance(p.x,p.y, Game.p1.x,Game.p1.y) < 0.6){
    const pl = Game.p1;

    // (B) Anthurus : ignore les parasites
    if (pl.species.id === 'anthurus') {
      // rien
    }
    // (A) Strophaire : téléporte le parasite le plus loin de l'AUTRE joueur
    else if (pl.species.id === 'stropharia'){
      const other = (Game.mode==='duo' ? Game.p2 : null);
      teleportParasiteFarFromPlayer(p, other || pl); // si solo par sécurité : loin du Stropharia
      return;
    }
    else {
      playerHit(pl, p);
    }
  }

  // --- Test J2 ---
  if(Game.mode==='duo' && Game.p2 && distance(p.x,p.y, Game.p2.x,Game.p2.y) < 0.6){
    const pl = Game.p2;

    if (pl.species.id === 'anthurus') {
      // rien
    } else if (pl.species.id === 'stropharia'){
      const other = Game.p1;
      teleportParasiteFarFromPlayer(p, other || pl);
      return;
    } else {
      playerHit(pl, p);
    }
  }
}

function anthurusCatchCheck(){
  if (Game.mode!=='duo') return;
  const A = (Game.p1 && Game.p1.species.id==='anthurus') ? Game.p1
          : (Game.p2 && Game.p2.species.id==='anthurus') ? Game.p2 : null;
  if (!A) return;

  const V = (A===Game.p1) ? Game.p2 : Game.p1;
  if (!V) return;

  // pas d’attrape si panneau, ni si victime invulnérable momentanément
  if (A.panelActive || A.powerTimer>0) return;
  if (V.invulnTimer>0 || V.hitGrace>0) return;

  if (distance(A.x,A.y,V.x,V.y) < 0.6){
    // traite comme une touche de parasite (perte de vie + respawn)
    playerHit(V, null);
  }
}


function playerHit(pl, hitter){
  // --- GIROLLE (cibarius) : invulnérable pendant la chasse et 1s après conversion ---
  if (pl.species.id === 'cibarius') {

    // 3.a Pendant la fenêtre de chasse : aucune perte de vie.
    if (pl.hunterWindow > 0) {
      // Si on percute un parasite non-serviteur -> conversion immédiate
      if (hitter && !hitter.servant) {
        releaseServant(pl.pid);
        convertToServant(hitter, pl.pid);
        pl.hunterWindow = 0;        // fin de la fenêtre de chasse
        pl.invulnTimer = 60;        // invulnérable encore 1 seconde
        (pl.pid===1?UI.power1:UI.power2).textContent='Serviteur ✓';
        sfxPower();

        // Fin de la panique déclenchée par la Girolle
        Game.girollePanic.active = false;
        Game.parasites.forEach(q => { q.fleeGirolle = 0; });
      }
      // Qu'il y ait conversion ou pas : aucune perte de vie pendant la chasse
      return;
    }

    // 3.b Après conversion : encore 1s d'invulnérabilité
    if (pl.invulnTimer > 0) {
      return; // aucune perte de vie
    }
  }

  if(pl.invisible) return;
  if(pl.hitGrace>0) return;

  // Bouclier du Cèpe : ignore 1 coup + knockback ciblé (avec domino)
  if(pl.shield){
    pl.shield=false;
    (pl.pid===1?UI.power1:UI.power2).textContent='—';
    pl.hitGrace = 45;  // ~0,75s invulnérabilité

    if(hitter){
      const target = computeKnockbackTarget(hitter, pl);
      const dir = [ (target.x - hitter.x), (target.y - hitter.y) ];
      const len = Math.hypot(dir[0],dir[1])||1;
      hitter.kbActive = true;
      hitter.kbTx = target.x;
      hitter.kbTy = target.y;
      hitter.kbSpeed = pl.speed * 2;   // 2× la vitesse du champignon
      hitter.kbDir = [dir[0]/len, dir[1]/len];
      hitter.scared = Math.max(hitter.scared, 90);
      hitter.path = []; hitter.lastSeen = null;
    } else {
      // fallback de sécurité
      repelEnemiesAround(pl, 2.2, 0.9);
    }

    sfxPower();
    return;
  }

  sfxHit();
  if(pl.pid===1){ Game.lives1--; UI.lives1.textContent=Game.lives1; }
  else { Game.lives2--; UI.lives2.textContent=Game.lives2; }

// Duo : condition "dernier vivant"
if (Game.mode==='duo'){
  const coop = isCoopWithStropharia();
  const p1Alive = Game.lives1 >= 0;
  const p2Alive = Game.lives2 >= 0;

  if (coop){
    if (!p1Alive || !p2Alive){
      const teamScore = Math.max(Game.score1, Game.score2);
      Game.score1 = teamScore; UI.score1.textContent = Game.score1;
      Game.score2 = teamScore; UI.score2.textContent = Game.score2;
      updateLeaderHUD();
      endMatch('Défaite — vous perdez ensemble');
      return;
    }
  } else {
    if(!p1Alive && p2Alive){ endMatch('J2 gagne — dernier vivant !'); return; }
    if(!p2Alive && p1Alive){ endMatch('J1 gagne — dernier vivant !'); return; }
  }
}


// SOLO : si on perd, on montre quand même le score puis on propose Rejouer
if (Game.mode!=='duo' && (pl.pid===1 ? Game.lives1 : Game.lives2) < 0) {
  endMatch('Défaite !');
  return;
}


  // Réapparition immédiate + flash 5s
  const s=findOpenTile(); pl.x=s.x+0.5; pl.y=s.y+0.5; pl.dir=[0,0];
  pl.respawnFlash = 5*60; // 5 s
  pl.invisible=false; pl.phase=false; pl.frozenTimer=0;
  // --- AJOUT : lueur 2s au respawn (sans spin)
  pl.glowTimer = Math.max(pl.glowTimer||0, 120);
}

// Update joueur
function updatePlayer(pl, dt){
  if(!pl) return;

  // Timers génériques
  pl.anim += dt;
  if (pl.tpGrace      > 0) pl.tpGrace--;
  if (pl.respawnFlash > 0) pl.respawnFlash--;
  if (pl.hitGrace     > 0) pl.hitGrace--;
  if (pl.hunterWindow > 0) pl.hunterWindow--;
  if (pl.glowTimer    > 0) pl.glowTimer--;
  if (pl.invulnTimer  > 0) pl.invulnTimer--;
  if (pl.madnessTimer > 0) pl.madnessTimer--;

 // Garde-fou anti “panneau zombie”
  if (!pl.panelActive && pl._panelEl) {
  closePowerPanel(pl);
}

  // Spin post-téléport
  if (pl.spinTimer > 0){
    pl.spinTimer--;
    pl.spinPhase = (pl.spinPhase || 0) + 0.25 * dt; // ~1.5 tours/s
  } else {
    pl.spinPhase = 0;
  }

  // Fin de panique Girolle si fenêtre écoulée
  if (pl.species.id === 'cibarius' && pl.hunterWindow === 0 && Game.girollePanic.active && Game.girollePanic.ownerPid === pl.pid){
    Game.girollePanic.active = false;
    Game.parasites.forEach(q => { q.fleeGirolle = 0; });
  }

  // Gestion d’expiration du pouvoir (tous champignons)
  if (pl.powerTimer > 0){
    pl.powerTimer--;
    if (pl.powerTimer <= 0){
      // extinction standard des effets
      pl.invisible = false; pl.speedBoost = 1; pl.shield = false; pl.phase = false;
      pl.girolleTrapImmune = false; pl.trumpetTrapImmune = false;

      // fin de panneau (Stropharia/Anthurus)
      if (pl.panelActive){
        pl.panelActive = false;
        pl.inputLocked = false;
        if (typeof closePowerPanel === 'function') closePowerPanel(pl);
      }

      // Trompette : CD 10s en sortie d’invisibilité
      if (pl.species.id === 'cornucopioides') pl.trumpetCd = 600;

      // HUD reset
      const el = (pl.pid === 1 ? UI.power1 : UI.power2);
      if (el) el.textContent = '—';

      // Anthurus : rafraîchir la jauge si dispo
      if (pl.species.id === 'anthurus' && typeof refreshPowerHUD === 'function') refreshPowerHUD(pl);
    }
  }

  // Cooldowns spécifiques
  if (pl.trumpetCd    > 0) pl.trumpetCd--;
  if (pl.phaseCooldown> 0) pl.phaseCooldown--;

  // === Entrées / Déplacement ===
  // Pendant un panneau actif, on bloque le déplacement (les flèches/ZQSD servent à la navigation du panneau)
  const movementLocked = !!pl.inputLocked || pl.frozenTimer > 0;

  // Direction souhaitée (inversion gérée dans inputDirForPlayer)
  const want = movementLocked ? [0,0] : inputDirForPlayer(pl);
  if (want[0] || want[1]) pl.nextDir = want.slice(0);

  const tx  = Math.floor(pl.x), ty = Math.floor(pl.y);
  const cx  = tx + 0.5,        cy = ty + 0.5;
  const TURN_EPS = 0.45;

  if (pl.frozenTimer > 0){
    pl.frozenTimer--;
    pl.dir = [0,0];
  } else if (!movementLocked) {
    // Acceptation d’un virage si proche de l’axe
    if ((pl.nextDir[0] || pl.nextDir[1])){
      const nearAxis = (pl.nextDir[0] !== 0) ? Math.abs(pl.y - cy) < TURN_EPS : Math.abs(pl.x - cx) < TURN_EPS;
      if (nearAxis && openTile(tx + pl.nextDir[0], ty + pl.nextDir[1], pl)){
        if (pl.nextDir[0] !== 0) pl.y = cy; else pl.x = cx;
        pl.dir = pl.nextDir.slice(0);
      }
    }

    // Vitesse de base + modifs
    let spdMul = (pl.speedBoost || 1);

    // Girolle : +30% en hard UNIQUEMENT pendant la chasse (avant conversion)
    if (pl.species.id === 'cibarius' && SelectedDifficulty.id === 'hard' && pl.hunterWindow > 0){
      spdMul *= 1.3;
    }

    const spd = pl.speed * spdMul * dt;

    // Mouvement
    if (pl.dir[0] !== 0){
      const sign = pl.dir[0];
      let toX = pl.x + sign * spd;
      const fromTileX = Math.floor(pl.x);
      const toTileX   = Math.floor(toX);
      if (toTileX !== fromTileX){
        const ahead = fromTileX + (sign > 0 ? 1 : -1);
        if (openTile(ahead, ty, pl)) { pl.x = toX; } else { pl.x = fromTileX + 0.5; pl.dir = [0,0]; }
      } else {
        pl.x = toX;
      }
      pl.y += clamp(cy - pl.y, -0.3, 0.3) * 0.6;
    }
    if (pl.dir[1] !== 0){
      const sign = pl.dir[1];
      let toY = pl.y + sign * spd;
      const fromTileY = Math.floor(pl.y);
      const toTileY   = Math.floor(toY);
      if (toTileY !== fromTileY){
        const ahead = fromTileY + (sign > 0 ? 1 : -1);
        if (openTile(tx, ahead, pl)) { pl.y = toY; } else { pl.y = fromTileY + 0.5; pl.dir = [0,0]; }
      } else {
        pl.y = toY;
      }
      pl.x += clamp(cx - pl.x, -0.3, 0.3) * 0.6;
    }
  }

  if (pl.dir[0] || pl.dir[1]) pl._lastDir = pl.dir.slice(0);

  // --- Tuile courante ---
  const ntX = Math.floor(pl.x), ntY = Math.floor(pl.y);

  // Vortex (joueur)
  if (Game.grid[ntY] && Game.grid[ntY][ntX] === VORTEX && !isVortexBlocked(ntX, ntY)){
    if (pl.tpGrace <= 0){
      teleportEntityToOtherVortex(pl, ntX, ntY);
      sfxPower();
    }
  }

  // Phalloïde : fin automatique après traversée d’UN mur
  if (pl.species.id === 'phalloides' && pl.phase){
    const isWall = !!(Game.grid[ntY] && Game.grid[ntY][ntX] === 1);
    if (!pl.phaseInsideWall && isWall){
      pl.phaseInsideWall = true;
    } else if (pl.phaseInsideWall && !isWall){
      pl.phase = false;
      pl.powerTimer = 0;
      pl.phaseInsideWall = false;
      pl.phaseCooldown = 300; // 5s
      const el = (pl.pid === 1 ? UI.power1 : UI.power2);
      if (el) el.textContent = '—';
    }
  }

  // --- Spores (tuile 2) ---
  if (Game.grid[ntY] && Game.grid[ntY][ntX] === 2){
    if (pl.species.id === 'stropharia'){
      // Stropharia NE CONSOMME PAS les spores (aucune modif de la grille / du score)
      // On laisse intact : pas de sfxEat(), pas de refreshPelletCell
    } else {
      // Consommation standard
      Game.grid[ntY][ntX] = 0;
      Game.remaining--;
      sfxEat();
      refreshPelletCell(ntX, ntY);

      // Trompette : compteur pour la durée dynamique
      pl.collectedSpores = (pl.collectedSpores || 0) + 1;

      // Anthurus : charge le pouvoir (10 spores nécessaires pour ouvrir le panel)
      if (pl.species.id === 'anthurus'){
        pl.anthurusCharge = (pl.anthurusCharge | 0) + 1;
        if (typeof refreshPowerHUD === 'function') refreshPowerHUD(pl);
      }

      // Score
      if (pl.pid === 1){ Game.score1 += 10; UI.score1.textContent = Game.score1; }
      else             { Game.score2 += 10; UI.score2.textContent = Game.score2; }
      updateLeaderHUD();
    }
  }

// --- Bonus ---
for (let i = Game.bonuses.length - 1; i >= 0; i--){
  const b = Game.bonuses[i];
  if (b.x === ntX && b.y === ntY){
    const didConsume = eatBonusFor(pl, b);   // ← retourne true si retiré du sol
    if (didConsume){
      Game.bonuses.splice(i, 1);
      refreshPelletCell(b.x, b.y);
    }
  }
}

  // --- Pièges (tuile 4) ---
  if (Game.grid[ntY] && Game.grid[ntY][ntX] === 4){
    const idx = Game.traps.findIndex(t => t.x === ntX && t.y === ntY);
    if (idx >= 0){
      const trap = Game.traps[idx];
      Game.traps.splice(idx, 1);
      Game.grid[ntY][ntX] = 0;
      if (!(pl.species.id === 'cornucopioides' && pl.trumpetTrapImmune)){
        if (trap.t === 0){ spawnEnemy(); }
        else { pl.frozenTimer = 5 * 60; }
      }
    }
  }
}

// === GLOBAL ===
function drawPreStartBeacons(){
  const drawOne = (pl, label) => {
    if(!pl) return;
    const x = pl.x * TILE, y = pl.y * TILE;
    const t = performance.now() / 1000;

    // halo pulsant
    const r = 22 + 6*Math.sin(t*2.1);
    const g = CTX.createRadialGradient(x, y, r*0.25, x, y, r*1.1);
    g.addColorStop(0.00, 'rgba(255,240,180,0.70)');
    g.addColorStop(0.55, 'rgba(255,210,100,0.28)');
    g.addColorStop(1.00, 'rgba(255,210,100,0.00)');

    CTX.save();
    CTX.globalCompositeOperation = 'screen';
    CTX.fillStyle = g;
    CTX.beginPath(); CTX.arc(x, y, r*1.1, 0, Math.PI*2); CTX.fill();

    // liseré
    CTX.globalCompositeOperation = 'source-over';
    CTX.lineWidth = 2;
    CTX.strokeStyle = 'rgba(255,230,150,0.9)';
    CTX.beginPath(); CTX.arc(x, y, r + 6, 0, Math.PI*2); CTX.stroke();

    // label J1/J2
    CTX.font = 'bold 12px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'bottom';
    CTX.fillStyle = '#fff';
    CTX.fillText(label, x, y - (r + 10));
    CTX.restore();
  };

  drawOne(Game.p1, 'J1');
  if (Game.mode === 'duo') drawOne(Game.p2, 'J2');
}


  
/* Rendu */
function draw(){
  if(!Game.themeLayer||!Game.wallsLayer){
    const g=CTX.createLinearGradient(0,0,0,H); g.addColorStop(0,'#1a1620'); g.addColorStop(1,'#0d0a12'); CTX.fillStyle=g; CTX.fillRect(0,0,W,H); return;
  }
  CTX.drawImage(Game.themeLayer,0,0);
    // ← AJOUT : sol sous tout le gameplay
  if (Game.floorLayer) CTX.drawImage(Game.floorLayer,0,0);

  CTX.drawImage(Game.pelletsLayer,0,0);
  drawTrapsAndBonuses();
  CTX.drawImage(Game.wallsLayer,0,0);

  Game.particles.forEach(pa=>{
    if(pa.type==='cloud'){ CTX.globalAlpha=0.2; CTX.beginPath(); CTX.arc(pa.x,pa.y,pa.r,0,6.28); CTX.fillStyle='#ffffff'; CTX.fill(); CTX.globalAlpha=1; }
  });

 // --- NOUVEAU rendu parasites (sprites PNG 1..7 + rotation) ---
Game.parasites.forEach(p=>{
  const px = p.x * TILE;
  const py = p.y * TILE;

  // helper local : angle en radian depuis dir discrète (sprite "tête vers le haut")
  const angleFromDir4Local = (d) => {
    if (!d) return 0;
    if (d[1] === -1) return 0;                 // haut
    if (d[0] ===  1) return Math.PI / 2;       // droite
    if (d[1] ===  1) return Math.PI;           // bas
    if (d[0] === -1) return -Math.PI / 2;      // gauche
    return 0;
  };

  // --- couches sous le sprite ---
  // Frozen : halo glacé
  if (p.frozen > 0) {
    CTX.save();
    CTX.globalAlpha = 0.35;
    CTX.fillStyle = '#9ad6ff';
    CTX.beginPath();
    CTX.arc(px, py, 12, 0, Math.PI * 2);
    CTX.fill();
    CTX.restore();
  }

  // Serviteur : glow turquoise
  if (p.servant) {
    CTX.save();
    const g = CTX.createRadialGradient(px, py, 6, px, py, 18);
    g.addColorStop(0, 'rgba(223,255,248,0.7)');
    g.addColorStop(1, 'rgba(64,224,208,0)');
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(px, py, 18, 0, Math.PI * 2);
    CTX.fill();
    CTX.restore();
  }

  // --- sprite PNG + rotation ---
  const kind = Math.max(1, Math.min(7, (p.kind|0) || 1)); // borne 1..7
  const img  = loadImg(`Parasite_${kind}.png`);           // tes fichiers
  const ang  = (typeof p.faceAngle === 'number')
    ? p.faceAngle
    : angleFromDir4Local(p.dir || [0, -1]);               // fallback si pas d’anim

  const size = TILE * 0.9;

  if (img.complete) {
    CTX.save();
    CTX.translate(px, py);
    CTX.rotate(ang);
    CTX.drawImage(img, -size/2, -size/2, size, size);
    CTX.restore();
  }

  // Aveugle : bandeau noir
  if (p.blind > 0) {
    CTX.save();
    CTX.globalAlpha = 0.6;
    CTX.fillStyle = '#000';
    CTX.fillRect(px - size*0.5, py - size*0.08, size, size*0.16);
    CTX.restore();
  }

  // Confus : icône ✳ au-dessus
  if (p.confusedTimer > 0) {
    CTX.save();
    CTX.globalAlpha = 0.9;
    CTX.font = '12px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.fillStyle = '#fff';
    CTX.fillText('✳', px, py - (size*0.8));
    CTX.restore();
  }

  // Effet "scared" : flash blanc
  if (p.scared > 0) {
    CTX.save();
    CTX.globalAlpha = 0.4;
    CTX.fillStyle = '#fff';
    CTX.fillRect(px - 10, py - 10, 20, 20);
    CTX.restore();
  }

  // Traînée knockback
  if (p.kbActive) {
    CTX.save();
    CTX.globalAlpha = 0.15;
    CTX.fillStyle = '#ffe6aa';
    CTX.beginPath();
    CTX.arc(px, py, 8, 0, Math.PI * 2);
    CTX.fill();
    CTX.restore();
  }
});


  if(Game.p1) drawPlayerEntity(Game.p1);
  if(Game.mode==='duo' && Game.p2) drawPlayerEntity(Game.p2);

 // État pré-départ / pause / compte à rebours
if (Game.preStart) {
  // balises infinies sur les positions des joueurs
  drawPreStartBeacons();

  // petit bandeau discret en haut-gauche (ne masque pas le labyrinthe)
  CTX.save();
  const pad = 10;
  const text = 'P pour lancer — libre d’explorer visuellement';
  CTX.font = 'bold 16px system-ui';
  const w = CTX.measureText(text).width + pad*2;
  const h = 28;

  CTX.fillStyle = 'rgba(0,0,0,0.45)';
  CTX.fillRect(10, 10, w, h);
  CTX.fillStyle = '#fff';
  CTX.textAlign = 'left';
  CTX.textBaseline = 'middle';
  CTX.fillText(text, 10 + pad, 10 + h/2);
  CTX.restore();
}
else if (Game.paused && Game.countdown === 0){
  // vraie pause en cours de partie : overlay central classique
  CTX.save(); 
  CTX.globalAlpha=0.35; CTX.fillStyle='#000'; CTX.fillRect(0,0,W,H);
  CTX.globalAlpha=1; CTX.fillStyle='#fff'; CTX.font='bold 42px system-ui'; 
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillText('PAUSE — P pour reprendre', W/2, H*0.5); 
  CTX.restore();
}
else if (Game.countdown > 0){
  const sec=Math.ceil(Game.countdown/60);
  CTX.save(); CTX.globalAlpha=0.3; CTX.fillStyle='#000'; CTX.fillRect(0,0,W,H); CTX.globalAlpha=1;
  CTX.fillStyle='#fff'; CTX.font='bold 120px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillText(sec.toString(), W/2, H*0.5); 
  CTX.restore();
}

}

function drawTrapsAndBonuses(){
  Game.traps.forEach(t=>{
    const px=t.x*TILE+TILE/2,py=t.y*TILE+TILE/2;
    CTX.save();
    if(t.t===0){ CTX.beginPath(); CTX.moveTo(px,py-8); CTX.lineTo(px-8,py+8); CTX.lineTo(px+8,py+8); CTX.closePath(); CTX.fillStyle='#a83b3b'; CTX.fill(); }
    else { CTX.beginPath(); CTX.ellipse(px,py,10,6,0,0,6.28); CTX.fillStyle='#7fbf7f88'; CTX.fill(); }
    CTX.restore();
  });
  if(Game.muscariaTrap1 && Game.muscariaTrap1.active){
    const px=Game.muscariaTrap1.x*TILE+TILE/2, py=Game.muscariaTrap1.y*TILE+TILE/2;
    CTX.save(); CTX.beginPath(); CTX.arc(px,py,13,0,Math.PI*2); CTX.fillStyle='rgba(255,64,128,0.18)'; CTX.fill();
    CTX.lineWidth=3; CTX.strokeStyle='#ff3b7a'; CTX.stroke(); CTX.font='bold 12px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle='#ffd6e6'; CTX.fillText('π1',px,py); CTX.restore();
  }
  if(Game.muscariaTrap2 && Game.muscariaTrap2.active){
    const px=Game.muscariaTrap2.x*TILE+TILE/2, py=Game.muscariaTrap2.y*TILE+TILE/2;
    CTX.save(); CTX.beginPath(); CTX.arc(px,py,13,0,Math.PI*2); CTX.fillStyle='rgba(64,128,255,0.18)'; CTX.fill();
    CTX.lineWidth=3; CTX.strokeStyle='#3b7aff'; CTX.stroke(); CTX.font='bold 12px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle='#d6e0ff'; CTX.fillText('π2',px,py); CTX.restore();
  }
  Game.bonuses.forEach(b=>{
    const px=b.x*TILE+TILE/2,py=b.y*TILE+TILE/2;
    CTX.save();
    let col='#fff',label='?';
    if(b.kind==='life'){col='#ff5c6c';label='❤';}
    if(b.kind==='speed'){col='#ffe066';label='⚡';}
    if(b.kind==='power'){col='#9ad6ff';label='★';}
    if(b.kind==='score'){col='#a1ffa4';label='⨁';}
    if(b.kind==='freeze'){col='#d8c7ff';label='❄';}
    CTX.beginPath(); CTX.arc(px,py,10,0,6.28); CTX.fillStyle=col+'33'; CTX.fill(); CTX.strokeStyle=col; CTX.lineWidth=2; CTX.stroke();
    CTX.font='16px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle=col; CTX.fillText(label,px,py+1);
    CTX.restore();
  });
// --- VORTEX 🌀 (rotation continue de l’emoji) ---
Game.vortexes.forEach(v=>{
  const px = v.x*TILE + TILE/2;
  const py = v.y*TILE + TILE/2;

  // vitesse de rotation (~0.003 rad/ms -> ~1 tour toutes ~2s)
  const angle = performance.now() * 0.003;

  CTX.save();

  // anneau externe (fixe)
  CTX.beginPath();
  CTX.arc(px, py, 14, 0, Math.PI*2);
  CTX.fillStyle = 'rgba(150,200,255,0.12)';
  CTX.fill();
  CTX.lineWidth = 2;
  CTX.strokeStyle = 'rgba(150,200,255,0.55)';
  CTX.stroke();

  // cœur (fixe)
  CTX.beginPath();
  CTX.arc(px, py, 8, 0, Math.PI*2);
  CTX.fillStyle = 'rgba(90,140,255,0.35)';
  CTX.fill();

  // emoji en rotation
  CTX.translate(px, py);
  CTX.rotate(angle);
  CTX.font = '16px system-ui';
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  CTX.fillStyle = '#e8f0ff';
  CTX.fillText('🌀', 0, 1);

  CTX.restore();
});
}

function drawPlayerEntity(pl){
  const x = pl.x * TILE, y = pl.y * TILE;

  // --- GLOW luciole (respawn / départ / téléport) ---
  if(pl.glowTimer > 0){
    const t = performance.now() / 200;
    const base = 0.6 + 0.4 * Math.sin(t * 2*Math.PI);  // pulsation
    const fade = pl.glowTimer / 120;                   // décroissance
    const intensity = base * fade;

    const r = 28 + 10 * Math.sin(t * 1.3);
    const g = CTX.createRadialGradient(x, y, r*0.25, x, y, r);
    g.addColorStop(0, `rgba(255,240,180,${0.65*intensity})`);
    g.addColorStop(0.4, `rgba(255,220,120,${0.25*intensity})`);
    g.addColorStop(1, 'rgba(255,220,120,0)');

    CTX.save();
    CTX.globalCompositeOperation = "screen";
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(x, y, r, 0, Math.PI*2);
    CTX.fill();
    CTX.restore();
  }

  // — Indicateur "power en poche"
if (pl.superPowerHeld){
  CTX.save();
  CTX.translate(x, y - 26);          // juste au-dessus de la tête
  // halo
  const t = performance.now() * 0.006;
  const r = 10 + 2*Math.sin(t*3.0);
  const g = CTX.createRadialGradient(0,0,2, 0,0,r);
  g.addColorStop(0, 'rgba(255,255,200,0.9)');
  g.addColorStop(1, 'rgba(255,255,200,0.0)');
  CTX.globalCompositeOperation = 'screen';
  CTX.fillStyle = g;
  CTX.beginPath(); CTX.arc(0,0,r,0,Math.PI*2); CTX.fill();

  // étoile
  CTX.globalCompositeOperation = 'source-over';
  CTX.font = '14px system-ui';
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  CTX.fillStyle = '#fff';
  CTX.fillText('★', 0, 0);
  CTX.restore();
}

  
  // --- Fonction de rendu champignon (sprite centré) ---
  const drawMushroomCentered = (cx, cy) => {
    if(pl.species.id==='cornucopioides')      drawTrumpet(CTX, cx, cy, 28, false, (pl.powerTimer>0));
    else if(pl.species.id==='muscaria')       drawAmanita(CTX, cx, cy, 28, false);
    else if(pl.species.id==='cibarius')       drawChanterelle(CTX, cx, cy, 28, false);
    else if(pl.species.id==='edulis')         drawCep(CTX, cx, cy, 28, false);
    else if(pl.species.id==='morchella')      drawMorel(CTX, cx, cy, 28, false);
    else if(pl.species.id==='phalloides')     drawPhalloides(CTX, cx, cy, 28, false);
    else if(pl.species.id==='stropharia')    drawStropharia(CTX, cx, cy, 28, false);
    else if(pl.species.id==='anthurus')      drawAnthurus(CTX, cx, cy, 28, false);
  };

  // --- SPIN après téléportation ---
  if (pl.spinTimer > 0){
    const angle = performance.now() / 300; // rotation fluide
    CTX.save();
    CTX.translate(x, y);
    CTX.rotate(angle);
    drawMushroomCentered(0, 0); // champignon tournant
    CTX.restore();
  } else {
    drawMushroomCentered(x, y); // affichage normal
  }

  // === NOUVEAU : halo/indicateur de folie (inversion contrôles)
  if (pl.madnessTimer > 0) {
    const t = performance.now() / 200;
    const k = (pl.madnessTimer / 300); // fade out léger
    const R = 22 + 3*Math.sin(t*2.4);

    // Contour magenta animé (zigzag)
    CTX.save();
    CTX.translate(x, y);
    CTX.rotate(Math.sin(t*1.1)*0.15);
    CTX.beginPath();
    for (let i=0;i<14;i++){
      const ang = (i/14)*Math.PI*2;
      const rr = R + ((i%2) ? 5 : -2);
      CTX.lineTo(Math.cos(ang)*rr, Math.sin(ang)*rr);
    }
    CTX.closePath();
    CTX.globalAlpha = 0.65*k;
    CTX.lineWidth = 2;
    CTX.strokeStyle = 'rgba(200,80,255,0.95)';
    CTX.stroke();
    CTX.restore();

    // Icône ✳ flottante
    CTX.save();
    CTX.font = '18px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.globalAlpha = 0.9*k;
    CTX.fillText('✳', x, y - 28 - 4*Math.sin(t*2.0));
    CTX.restore();
  }

  // --- Effets supplémentaires ---
  if(pl.frozenTimer > 0){
    CTX.save(); CTX.globalAlpha=0.35; CTX.fillStyle='#9ad6ff';
    CTX.beginPath(); CTX.arc(x, y, 16, 0, Math.PI*2); CTX.fill(); CTX.restore();
  }

if (pl.powerTimer > 0) {
  if (pl.species.id === 'cornucopioides' && pl.invisible) {
    // --- Halo noir encre, moins opaque, placé DERRIÈRE le sprite ---
    const t = performance.now();
    const baseR = 22;
    const pulse = 4 * Math.sin(t / 180);
    const R = baseR + pulse;

    // Dégradé radial plus léger : silhouette visible
    const g = CTX.createRadialGradient(x, y, R * 0.15, x, y, R * 1.25);
    g.addColorStop(0.00, 'rgba(0,0,0,0.58)');
    g.addColorStop(0.50, 'rgba(0,0,0,0.42)');
    g.addColorStop(1.00, 'rgba(0,0,0,0.00)');

    CTX.save();
    // place le halo derrière ce qui est déjà dessiné (la Trompette)
    CTX.globalCompositeOperation = 'destination-over';
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(x, y, R * 1.15, 0, Math.PI * 2);
    CTX.fill();

    // petites nappes/taches discrètes
    for (let i = 0; i < 4; i++) {
      const ang = (t / 520) + i * (Math.PI / 2);
      const ox = Math.cos(ang) * 6;
      const oy = Math.sin(ang) * 4;
      const r2 = R * 0.5;
      const g2 = CTX.createRadialGradient(x+ox, y+oy, r2 * 0.1, x+ox, y+oy, r2);
      g2.addColorStop(0.00, 'rgba(0,0,0,0.48)');
      g2.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      CTX.beginPath();
      CTX.fillStyle = g2;
      CTX.arc(x + ox, y + oy, r2, 0, Math.PI * 2);
      CTX.fill();
    }
    CTX.restore();

    // Compte à rebours (secondes) — minuscule blanc
    const secs = Math.max(0, Math.ceil(pl.powerTimer / 60));
    CTX.save();
    CTX.font = '10px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.lineWidth = 3;
    CTX.strokeStyle = 'rgba(0,0,0,0.85)';
    CTX.strokeText(String(secs), x, y);
    CTX.fillStyle = '#ffffff';
    CTX.fillText(String(secs), x, y);
    CTX.restore();
  } else {
    // autres pouvoirs : garde ton effet existant OU mets rien si tu ne veux plus de cercle
    const r = 12 + (Math.sin(performance.now() / 120) + 1) * 6;
    CTX.beginPath(); CTX.arc(x, y, r, 0, Math.PI * 2);
    CTX.lineWidth = 2; CTX.strokeStyle = 'rgba(255,255,255,0.55)'; CTX.stroke();
  }
}


  if(pl.respawnFlash > 0){
    const t=performance.now()/120;
    const blink = (Math.floor(t)%2===0) ? 0.85 : 0.35;
    const r=22 + 6*Math.sin(performance.now()/180);
    CTX.save();
    CTX.globalAlpha = blink;
    CTX.beginPath(); CTX.arc(x,y,r,0,Math.PI*2);
    CTX.lineWidth=4; CTX.strokeStyle = 'rgba(255,255,180,0.95)';
    CTX.stroke();
    CTX.restore();
  }

  if(pl.species.id==='edulis' && pl.hitGrace > 0){
    const t = (45 - pl.hitGrace) / 45;
    const r = 12 + t * 14;
    CTX.save();
    CTX.globalAlpha = 0.35*(1 - t);
    CTX.beginPath();
    CTX.arc(x, y, r, 0, Math.PI*2);
    CTX.lineWidth = 3;
    CTX.strokeStyle = 'rgba(255,230,160,0.9)';
    CTX.stroke();
    CTX.restore();
  }
}


/* Fin de match */
function endMatch(message){
  Game.paused=true; Game.countdown=0;
  const ov=document.createElement('div'); ov.className='ov'; const card=document.createElement('div'); card.className='card'; ov.appendChild(card);
  const t=document.createElement('div'); t.className='title'; t.textContent=message; card.appendChild(t);
  const sub = document.createElement('div'); sub.className = 'sub';
  sub.textContent = (Game.mode === 'duo')
    ? `Scores — J1: ${Game.score1} · J2: ${Game.score2}`
    : `Score : ${Game.score1}`;
  card.appendChild(sub);
  const btn=document.createElement('button'); btn.className='btn'; btn.textContent='Rejouer'; btn.addEventListener('click', ()=>{ ov.remove(); openOverlay(); });
  card.appendChild(btn);
  document.body.appendChild(ov);
}

/* Auto tests + Init */
(function selfTests(){ try{
  console.assert(COLS>0&&ROWS>0,'grid dims');
  const m=genLevel(12345);
  console.assert(isGridShape(m,COLS,ROWS),'maze dims');
  const pellets=m.flat().filter(v=>v===2).length; console.assert(pellets>COLS,'pellets enough');
  console.assert(typeof findNearestPellet==='function','nearest pellet helper');
} catch(e){ console.error('Self-tests failed',e); }})();

function init(){
  try {
    // 1) Vérifs canvas/contexte
    const c = document.getElementById('game');
    if (!c) throw new Error('Canvas #game introuvable.');
    const ctx = c.getContext('2d');
    if (!ctx) throw new Error('Impossible d’obtenir le contexte 2D du canvas.');

    // 2) Pré-chargement images (protégé)
    try { preloadCoreImages(); } 
    catch (e) { console.error('Préload images a échoué :', e); }

    // 3) Overlay de sélection (protégé)
createOverlay();

    // 4) Boucle
    loop();
  } catch (e) {
    console.error('Init jeu a échoué :', e);
    alert("Une erreur a empêché l’ouverture du menu.\nRegarde la console pour le détail (F12).");
  }
}

// Lance toujours via DOMContentLoaded pour éviter toute course.
document.addEventListener('DOMContentLoaded', init);

/* =================== FIN =================== */
</script>
</body>
</html>
