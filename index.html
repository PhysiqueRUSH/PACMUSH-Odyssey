<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PACMUSH ODYSSEY — MushRush Maze (Solo & 2 Joueurs)</title>
<style>
  :root { --bg:#0b0a0e; --card:#16131b; --pill:#1b141e; --line:#ffffff22; --shadow:#00000055; --text:#fff7ea; }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px}
  #hud{display:flex;gap:12px;align-items:center;user-select:none;font-weight:700;letter-spacing:.3px;flex-wrap:wrap;justify-content:center}
  .pill{padding:6px 10px;border-radius:999px;background:var(--pill);border:1px solid var(--line);box-shadow:0 3px 10px var(--shadow)}
  #legend{opacity:.9;font-size:14px}
  #game{display:block;width:1100px;max-width:95vw;height:auto;background:#0f0c14;border-radius:18px;border:2px solid #00000055;box-shadow:0 22px 70px #000000aa}
  .ov{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999}
  .card{max-width:1100px;width:92vw;background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 20px 80px #0009;padding:18px;max-height:88vh;overflow:auto}
  .title{font-weight:800;font-size:28px}
  .sub{opacity:.9}
  .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));margin-top:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badge{background:#ffffff10;border:1px solid var(--line);border-radius:999px;padding:2px 8px;font-size:12px}
  .btn{background:#0e0b13;border:1px solid var(--line);border-radius:10px;padding:10px 12px;font-weight:700;cursor:pointer;color:var(--text)}
  .btn[disabled]{opacity:.6;cursor:not-allowed}
  .sectionTitle{margin-top:14px;font-weight:800}
  .choice.disabled{opacity:.5;filter:grayscale(60%);pointer-events:none}
</style>
</head>
<body>
  <audio id="bgm" src="mushroom_hill_zone.mp3" loop></audio>
  <div id="wrap">
    <div id="hud">
      <div class="pill">Mode : <span id="mode">Solo</span></div>
      <div class="pill" id="leaderPill" style="display:none">Leader : <span id="leaderText" style="color:#ff4d4d;font-weight:800">—</span></div>
      <div class="pill">J1 — Score: <span id="score1">0</span> · Vies: <span id="lives1">3</span> · Pouvoir: <span id="power1">—</span></div>
      <div class="pill" id="p2hud" style="display:none">J2 — Score: <span id="score2">0</span> · Vies: <span id="lives2">3</span> · Pouvoir: <span id="power2">—</span></div>
      <div class="pill">Difficulté : <span id="diff">Guerre des Spores</span></div>
      <div id="legend" class="pill">J1: Flèches + Entrée · J2: ZQSD + F · P: pause/CR · O: menu</div>
    </div>
    <canvas id="game" width="1100" height="880" aria-label="PACMUSH ODYSSEY"></canvas>
  </div>

<script>
  // 🎵 Gestion musique
let bgm;

function initMusic() {
  bgm = document.getElementById("bgm");
  bgm.volume = 0.4; // volume de 0.0 (muet) à 1.0 (max)
}

function startMusic() {
  if (bgm) {
    bgm.play().catch(e => {
      console.log("Lecture auto bloquée par le navigateur :", e);
    });
  }
}

function stopMusic() {
  if (bgm) bgm.pause();
}

// Initialisation musique
initMusic();

// ⚠️ Les navigateurs bloquent la lecture automatique,
// on démarre la musique dès le 1er clic ou touche
document.addEventListener("keydown", startMusic, {once:true});
document.addEventListener("click", startMusic, {once:true});

/* =================== CODE COMPLET =================== */
/* ============ Réfs UI ============ */
const CANVAS = document.getElementById('game');
const CTX = CANVAS.getContext('2d');
const W = CANVAS.width, H = CANVAS.height;
const UI = {
  leaderPill: document.getElementById('leaderPill'),
  leaderText: document.getElementById('leaderText'),
  mode:document.getElementById('mode'),
  diff:document.getElementById('diff'),
  score1:document.getElementById('score1'),
  lives1:document.getElementById('lives1'),
  power1:document.getElementById('power1'),
  score2:document.getElementById('score2'),
  lives2:document.getElementById('lives2'),
  power2:document.getElementById('power2'),
  p2hud:document.getElementById('p2hud'),
  overlay:null, choices1:null, choices2:null, startBtn:null, modeSel:null
};

/* ============ Constantes ============ */
const TILE=28;
const COLS=Math.max(5,(W/TILE)|0);
const ROWS=Math.max(5,(H/TILE)|0);

/* Difficultés */
const DIFFICULTIES=[
  {id:'easy', name:'Cueillette du dimanche', label:'Cueillette du dimanche — facile', factor:0.25},
  {id:'medium', name:'Chiens Truffiers', label:'Chiens Truffiers — moyen', factor:0.5},
  {id:'hard', name:'Guerre des Spores', label:'Guerre des Spores — difficile', factor:1}
];
let SelectedDifficulty=DIFFICULTIES[2];

const MATCH_LEVELS_SOLO=1;
const MATCH_LEVELS_DUO=1;

// --- Semences aléatoires par session de jeu ---
let SESSION_SEEDS = [];
function reseedSession(levelCount){
  const n = Math.max(levelCount|0, 4);
  if (window.crypto && crypto.getRandomValues) {
    const arr = new Uint32Array(n);
    crypto.getRandomValues(arr);
    SESSION_SEEDS = Array.from(arr, v => (v>>>0) ^ (Date.now()>>>0) ^ ((Math.random()*1e9)|0));
  } else {
    SESSION_SEEDS = Array.from({length:n}, () => ((Date.now() + Math.random()*1e9)|0)>>>0);
  }
}


/* ============ Assets (sprites PNG fournis) ============ */
const SPRITES_BY_SPECIES = {
  cornucopioides: { game: 'champignon_6_bordered.png', ui: 'champignon_6_bordered.png' }, // Trompette de la mort
  muscaria:       { game: 'champignon_3.png',          ui: 'champignon_3.png' },          // Amanite tue-mouches
  cibarius:       { game: 'champignon_1.png',          ui: 'champignon_1.png' },          // Girolle
  edulis:         { game: 'champignon_4.png',          ui: 'champignon_4.png' },          // Cèpe
  morchella:      { game: 'champignon_5_bordered.png', ui: 'champignon_5_bordered.png' }, // Morille
  phalloides:     { game: 'champignon_2.png',          ui: 'champignon_2.png' },          // Amanite phalloïde
};

const _IMG_CACHE = new Map();
function loadImg(src){
  if(_IMG_CACHE.has(src)) return _IMG_CACHE.get(src);
  const i=new Image(); i.src=src; i.decoding='async'; i.loading='eager';
  _IMG_CACHE.set(src,i);
  return i;
}

// --- ARBRES PNG (à la racine du projet, sinon ajuste les chemins) ---
const TREE_PNG = {
  chene: 'chene.png',
  pin:   'pin.png'
};

// Choix stable (même case -> même image) en fonction de la case et du niveau
function pickTreeSpriteAt(x, y){
  // hash simple et stable basé sur coord + index de niveau
  const h = (((x*73856093) ^ (y*19349663) ^ (LEVEL_INDEX*83492791)) >>> 0);
  return (h & 1) ? TREE_PNG.pin : TREE_PNG.chene;
}

  
function getSpritePath(speciesId, forUI=false){
  const rec = SPRITES_BY_SPECIES[speciesId];
  if(!rec) return null;
  return forUI ? rec.ui : rec.game;
}
function drawImgCenteredPath(path, x, y, s, ghost=false){
  if(!path) return;
  const img = loadImg(path);
  if(!img.complete) return;
  CTX.save();
  if(ghost) CTX.globalAlpha = 0.8;
  CTX.drawImage(img, x - s/2, y - s/2, s, s);
  CTX.restore();
}

/* ============ Entrées clavier ============ */
const Keys=Object.create(null);
addEventListener('keydown', (e)=>{
  const k=e.key.toLowerCase();
  Keys[k]=true;
  if(['arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();

  // Activation pouvoirs  — J1: Entrée, J2: F
  if(e.key === 'Enter') triggerPower(1);
  if(k==='f') triggerPower(2);

  // pause / compte à rebours (début de niveau conservé)
  if(k==='p'){
    if(!Game.started) return;
    if(Game.countdown>0) return;
    if(Game.paused) startCountdown(180); else Game.paused=true;
  }

  if(k==='o'){ openOverlay(); }
});
addEventListener('keyup', (e)=>{ Keys[e.key.toLowerCase()]=false; });

function triggerPower(pid){
  if(!Game.started){ startGame(); return; }
  if(Game.countdown>0) return;
  const pl = pid===1?Game.p1:Game.p2;
  if(!pl) return;
 if (pl.powerTimer<=0) {
  // phalloides: bloque si cooldown actif
  if (pl.species.id==='phalloides' && pl.phaseCooldown>0) return;
   // Trompette : cooldown 10s après la fin d'un voile
  if (pl.species.id==='cornucopioides' && pl.trumpetCd>0) return;
   
  pl.species.use(pl);
  if(pl.nextPowerExtend && pl.nextPowerExtend>0){ pl.powerTimer+=pl.nextPowerExtend; pl.nextPowerExtend=0; }
  (pid===1?UI.power1:UI.power2).textContent=pl.species.power; sfxPower();
}
}

/* ============ Utils ============ */
const now=()=>performance.now();
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const distance=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
const makeLayerCanvas=(w,h)=>{ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; };
// === HUD Leader (visible UNIQUEMENT en mode 2 joueurs) ===
function updateLeaderHUD(){
  if (!UI.leaderPill || !UI.leaderText) return;

  if (Game.mode !== 'duo') {
    // Solo -> rien
    UI.leaderPill.style.display = 'none';
    UI.leaderText.textContent = '—';
    return;
  }

  // Duo -> on montre la pastille
  UI.leaderPill.style.display = '';
  let txt = 'Égalité';
  if (Game.score1 > Game.score2) txt = 'J1 en tête';
  else if (Game.score2 > Game.score1) txt = 'J2 en tête';
  UI.leaderText.textContent = txt;
}


/* ============ Audio (SFX uniquement — musique via <audio id="bgm">) ============ */
let ACTX = null, MASTER = null, STARTED = false;

// Initialise le contexte audio pour les effets sonores SEULEMENT (plus de musique synthé)
function ensureAudio(){
  if (STARTED) return;
  STARTED = true;
  ACTX = new (window.AudioContext || window.webkitAudioContext)();
  MASTER = ACTX.createGain();
  MASTER.gain.value = 0.18;
  MASTER.connect(ACTX.destination);
}

// Générateur d’effets (bips) pour le gameplay
function tone(time,freq,dur,type='sine',vol=0.2){
  if(!ACTX) return;
  const o=ACTX.createOscillator(), g=ACTX.createGain();
  o.type=type;
  o.frequency.setValueAtTime(freq,time);
  g.gain.value=0;
  g.gain.linearRampToValueAtTime(vol,time+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001,time+dur);
  o.connect(g); g.connect(MASTER);
  o.start(time); o.stop(time+dur);
}

// Effets sonores conservés
function sfxEat(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,740,.05,'triangle',.2); }
function sfxPower(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,520,.1,'sawtooth',.22); tone(t+.1,880,.1,'square',.18); }
function sfxHit(){ if(!ACTX) return; const t=ACTX.currentTime; tone(t,160,.08,'sawtooth',.3); }
function sfxWin(){ if(!ACTX) return; const t=ACTX.currentTime; [660,880,990,1320].forEach((f,i)=>tone(t+i*.1,f,.1,'triangle',.2)); }
function sfxLife(){ if(!ACTX) return; const t=ACTX.currentTime; [660,990,1320].forEach((f,i)=>tone(t+i*.08,f,.08,'sine',.22)); }

// On crée le contexte SFX au premier clic sur le canvas (aucune musique n’est lancée ici)
CANVAS.addEventListener('click', ensureAudio);


/* ============ Dessin entités ============ */
function drawTrumpet(ctx, cx, cy, size, icon, ghost){
  const p = getSpritePath('cornucopioides', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, !!ghost);
}
function drawAmanita(ctx, cx, cy, size, icon){
  const p = getSpritePath('muscaria', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawChanterelle(ctx, cx, cy, size, icon){
  const p = getSpritePath('cibarius', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawCep(ctx, cx, cy, size, icon){
  const p = getSpritePath('edulis', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawMorel(ctx, cx, cy, size, icon){
  const p = getSpritePath('morchella', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}
function drawPhalloides(ctx, cx, cy, size, icon){
  const p = getSpritePath('phalloides', !!icon);
  drawImgCenteredPath(p, cx, cy, size*1.15, false);
}

/* ============ Parasites (ennemis) ============ */
function drawParasite(ctx,cx,cy,size,kind,isServant,isBlind,isConfused){
  kind=kind||0; ctx.save(); ctx.translate(cx,cy); const r=size*0.35;
  if(isServant){
    ctx.shadowColor='rgba(64,224,208,0.8)'; ctx.shadowBlur=10;
    const grad=ctx.createRadialGradient(0,0,r*0.3,0,0,r*1.1);
    grad.addColorStop(0,'#DFFFF8'); grad.addColorStop(0.5,'#40E0D0'); grad.addColorStop(1,'#1A8C86');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.ellipse(0,0,r*1.2,r*0.9,0,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.stroke();
    ctx.shadowBlur=0; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(-r*0.8,-r*0.1,r*1.6,r*0.2);
  } else if(isBlind){
    ctx.fillStyle='#8b8b8b'; ctx.beginPath(); ctx.ellipse(0,0,r*1.2,r*0.9,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.fillRect(-r*1.0,-r*0.18, r*2.0, r*0.36);
    ctx.fillStyle='#222'; ctx.fillRect(-r*0.8,-r*0.1, r*1.6, r*0.2);
  } else {
    const col=['#9f3b3b','#3b6f9f','#9f8a3b','#7f3b9f'][kind%4];
    ctx.fillStyle=col; ctx.beginPath(); ctx.ellipse(0,0,r*1.2,r*0.9,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#111'; ctx.fillRect(-r*0.8,-r*0.1,r*1.6,r*0.2);
  }
  if(isConfused){
    ctx.fillStyle='#fff'; ctx.globalAlpha=0.9; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('✳',0,-r*1.6);
    ctx.globalAlpha=1;
  }
  ctx.restore();
}

/* ============ Espèces & pouvoirs ============ */
const Species = [
{
  id: 'cornucopioides',
  name: "Trompette de la mort",
  power: "Voile d'ombre",
  desc: "Devient invisible. Plus elle a dévoré de spores, plus ce pouvoir dure longtemps.",
  color: '#3d3630',
  draw: (c,x,y,s,icon,ghost) => drawTrumpet(c,x,y,s,icon,ghost),
  use: (me) => {
    // Durée dynamique : 1 seconde par tranche de 5 spores collectées
    const sec = Math.floor((me.collectedSpores || 0) / 5);
    const frames = sec * 60;

    // Si 0 spore → aucun effet (on ne lance pas le pouvoir)
    if (frames <= 0) {
      (me.pid===1 ? UI.power1 : UI.power2).textContent = '—';
      return;
    }

    // Activation du voile : invisibilité, vitesse réduite, pas d’immunité pièges
    me.powerTimer = frames;
    me.invisible  = true;    // indétectable pour l’IA
    me.speedBoost = 0.5;     // -50% de vitesse
    me.trumpetTrapImmune = false; // plus d’immunité aux pièges

    // Pas d'aveuglement des parasites
  }
},

  {
    id: 'muscaria',
    name: 'Amanite tue-mouches',
    power: 'Piège mycotique',
    desc: "Pose un piège qui téléporte les parasites.",
    color: '#c81d1d',
    draw: drawAmanita,
    use: (me) => {
      const tx = Math.floor(me.x), ty = Math.floor(me.y);
      if (me.pid===1) Game.muscariaTrap1 = {x:tx,y:ty,active:true};
      else            Game.muscariaTrap2 = {x:tx,y:ty,active:true};
      me.powerTimer = 120;
    }
  },
  
  {
    id: 'cibarius',
    name: 'Girolle',
    power: 'Serviteur (15s)',
    desc: 'Convertit 1 parasite en allié collecteur.',
    color: '#e6a100',
    draw: drawChanterelle,
    use: (me) => {
      me.powerTimer = 15*60;   // ~15s
      me.hunterWindow = 600;   // fenêtre de capture (10s)
      UI[me.pid===1 ? 'power1' : 'power2'].textContent = 'Serviteur ?';

      Game.girollePanic.active = true;
      Game.girollePanic.ownerPid = me.pid;
      Game.parasites.forEach(p => { p.fleeGirolle = me.hunterWindow; });
    }
  },
  
  {
    id: 'edulis',
    name: 'Cèpe',
    power: 'Robustesse',
    desc: 'Ignore un coup et repousse l’ennemi en chaîne.',
    color: '#7a4f2a',
    draw: drawCep,
    use: (me) => { me.powerTimer=360; me.shield=true; }
  },
  
  {
    id: 'morchella',
    name: 'Morille',
    power: 'Essaim de spores',
    desc: 'Chaos global, parasites désorientés.',
    color: '#6a4f2f',
    draw: drawMorel,
    use: (me) => {
      me.powerTimer = 600; // 10s d'aura
      const radTiles = Math.max(1, Math.floor(0.15 * Math.max(COLS, ROWS)));
      const cx = me.x, cy = me.y;

      Game.parasites.forEach(p => {
        if (Math.hypot(p.x-cx, p.y-cy) <= radTiles) {
          p.morilleChaos = 600;
          p.morilleOwner = me.pid;
          p.morilleNextSwitch = 0;
          p.morilleMode = null;
        }
      });
      // Option visuelle + léger fear local
      spawnSporeCloud(me.x, me.y, radTiles);
    }
  },
  
  {
    id: 'phalloides',
    name: 'Amanite phalloïde',
    power: 'Phase mycélienne',
    desc: 'Traverse les murs fins brièvement.',
    color: '#7a8b4b',
    draw: drawPhalloides,
    use: (me) => {
      if (me.phaseCooldown>0) return;
      me.phase = true;
      me.phaseInsideWall = false;
      me.powerTimer = 99999; // on coupera après sortie du 1er mur
    }
  }
];

let Selected1=Species[0], Selected2=Species[1];

/* =================== OVERLAY / MENU =================== */
function buildChoiceCard(sp, forPid){
  const otherSel = (forPid===1)? Selected2 : Selected1;
  const disabled = (Game && Game.mode==='duo' && otherSel && otherSel.id===sp.id);

  const div=document.createElement('div');
  div.className='choice'+(disabled?' disabled':'');
  div.style.cssText = 'background:#0e0b13;border:1px solid #ffffff1f;border-radius:12px;padding:14px;cursor:pointer;display:flex;gap:12px;align-items:center;';
  
  const icon = document.createElement('img');
  icon.src = getSpritePath(sp.id, true);
  icon.alt = sp.name;
  icon.style.cssText = 'width:84px;height:84px;object-fit:contain;image-rendering:crisp-edges;flex:0 0 auto;';

  const right=document.createElement('div'); right.style.display='grid'; right.style.gap='4px';
  const name=document.createElement('div'); name.style.fontWeight='800'; name.textContent=sp.name;
  const desc=document.createElement('div'); desc.style.opacity='.85'; desc.style.fontSize='13px'; desc.textContent='Pouvoir : '+sp.power+' — '+sp.desc;

  const row=document.createElement('div'); row.className='row';
  const badge=document.createElement('span'); badge.className='badge'; badge.textContent=sp.id;
  row.appendChild(badge);

  right.appendChild(name); right.appendChild(desc); right.appendChild(row);
  div.appendChild(icon); div.appendChild(right);

  if(!disabled){
    div.addEventListener('click', ()=>{
      if(forPid===1) Selected1=sp; else Selected2=sp;
      renderChoices(); updateStartButtonState();
    });
    div.addEventListener('dblclick', ()=>{
      if(updateStartButtonState()) { readOptionsFromOverlay(); startGame(); }
    });
  }
  const sel = forPid===1?Selected1:Selected2;
  if(sel && sel.id===sp.id){ div.style.outline='2px solid '+sp.color; div.style.boxShadow='0 0 0 4px '+sp.color+'33'; }

  return div;
}

function renderChoices(){
  if(UI.choices1){ UI.choices1.innerHTML=''; Species.forEach(sp=>UI.choices1.appendChild(buildChoiceCard(sp,1))); }
  if(UI.choices2){ UI.choices2.innerHTML=''; Species.forEach(sp=>UI.choices2.appendChild(buildChoiceCard(sp,2))); }
}

function updateStartButtonState(){
  if(!UI.overlay) return false;
  const duo = (UI.overlay.querySelector('input[name="modeSel"]:checked')?.value==='duo');
  const conflict = (duo && Selected1 && Selected2 && Selected1.id===Selected2.id);
  const btn = UI.startBtn;
  if(btn){
    btn.disabled = !!conflict;
    btn.textContent = conflict ? "Choisissez deux espèces différentes" : "Jouer";
  }
  return !conflict;
}

function readOptionsFromOverlay(){
  const root=UI.overlay||document;
  const sel=root.querySelector('#diffSel');
  if(sel){
    const found=DIFFICULTIES.find(d=>d.id===sel.value);
    if(found) SelectedDifficulty=found;
  }
  const modeSel=root.querySelector('input[name="modeSel"]:checked');
  if(modeSel){ Game.mode=modeSel.value; }
  if(Game.mode==='duo' && Selected1 && Selected2 && Selected1.id===Selected2.id){
    const alt = Species.find(s=>s.id!==Selected1.id);
    if(alt) Selected2 = alt;
  }
}

function attachOverlayEvents(ov){
  const btn=ov.querySelector('#startBtn');
  if(btn){
    btn.addEventListener('click', ()=>{
      if(!updateStartButtonState()) return;
      readOptionsFromOverlay();
      startGame();
    });
  }
  ov.addEventListener('change',(e)=>{
    if(e.target && e.target.name==='modeSel'){
      renderChoices();
      updateStartButtonState();
    }
  });
  ov.addEventListener('keydown', (e)=>{
    if((e.key==='Enter'||e.key===' ') && updateStartButtonState()){
      e.preventDefault(); readOptionsFromOverlay(); startGame();
    }
  });
}

function createOverlay(){
  if(UI.overlay) return;
  const ov=document.createElement('div'); ov.className='ov'; ov.id='overlay'; ov.setAttribute('role','dialog'); ov.setAttribute('aria-modal','true'); ov.tabIndex=0;
  const card=document.createElement('div'); card.className='card'; ov.appendChild(card);

  const title=document.createElement('div'); title.className='title'; title.textContent='PACMUSH ODYSSEY — MushRush 🍄';
  const sub=document.createElement('div'); sub.className='sub'; sub.textContent='Choisis le mode, la difficulté et vos champignons (en 2J : espèces différentes).';

  // Mode
  const secMode=document.createElement('div'); secMode.className='sectionTitle'; secMode.textContent='Mode de jeu';
  const rowMode=document.createElement('div'); rowMode.className='row';
  const r1=document.createElement('label'); r1.className='badge'; r1.style.cursor='pointer';
  r1.innerHTML='<input type="radio" name="modeSel" value="solo" checked> Solo';
  const r2=document.createElement('label'); r2.className='badge'; r2.style.cursor='pointer';
  r2.innerHTML='<input type="radio" name="modeSel" value="duo"> 2 joueurs (même clavier)';
  rowMode.appendChild(r1); rowMode.appendChild(r2);

  // Difficulté
  const secDiff=document.createElement('div'); secDiff.className='sectionTitle'; secDiff.textContent='Difficulté';
  const rowDiff=document.createElement('div'); rowDiff.className='row';
  const lab=document.createElement('label'); lab.textContent='Mode :'; lab.className='badge'; lab.setAttribute('for','diffSel');
  const sel=document.createElement('select'); sel.id='diffSel'; sel.className='select'; sel.style.cssText='background:#0e0b13;border:1px solid #ffffff22;border-radius:8px;padding:8px 10px;color:#fff7ea';
  DIFFICULTIES.forEach(d=>{
    const o=document.createElement('option'); o.value=d.id; o.textContent=d.label; if(d.id===SelectedDifficulty.id) o.selected=true; sel.appendChild(o);
  });
  rowDiff.appendChild(lab); rowDiff.appendChild(sel);

  // Choix champignons
  const secVar1=document.createElement('div'); secVar1.className='sectionTitle'; secVar1.textContent='Joueur 1 — Variété';
  const grid1=document.createElement('div'); grid1.id='choices1'; grid1.className='grid';
  const secVar2=document.createElement('div'); secVar2.className='sectionTitle'; secVar2.textContent='Joueur 2 — Variété (mode 2J)';
  const grid2=document.createElement('div'); grid2.id='choices2'; grid2.className='grid';

  const footer=document.createElement('div'); footer.className='row'; footer.style.justifyContent='space-between'; footer.style.marginTop='12px';
  const rowL=document.createElement('div'); rowL.className='row';
  ['J1: Flèches/Entrée','J2: ZQSD/F','P: pause + CR 3s (début)','O: menu'].forEach(t=>{ const b=document.createElement('span'); b.className='badge'; b.textContent=t; rowL.appendChild(b); });
  const btn=document.createElement('button'); btn.id='startBtn'; btn.textContent='Jouer'; btn.className='btn';
  footer.appendChild(rowL); footer.appendChild(btn);

  card.appendChild(title); card.appendChild(sub);
  card.appendChild(secMode); card.appendChild(rowMode);
  card.appendChild(secDiff); card.appendChild(rowDiff);
  card.appendChild(secVar1); card.appendChild(grid1);
  card.appendChild(secVar2); card.appendChild(grid2);
  card.appendChild(footer);

  document.body.appendChild(ov);
  UI.overlay=ov; UI.choices1=grid1; UI.choices2=grid2; UI.startBtn=btn; attachOverlayEvents(ov);
  renderChoices(); updateStartButtonState();
  setTimeout(()=>ov.focus(),0);
}

function openOverlay(){
  if(UI.overlay) return;
  Game.paused=true; Game.countdown=0;
  createOverlay();
}

function startGame(){
  if(UI.overlay){ UI.overlay.remove(); UI.overlay=null; }

  // AJOUT : purge défensive des anciens états (si des joueurs existent)
  if (Game.p1) resetPlayerRuntimeState(Game.p1);
  if (Game.p2) resetPlayerRuntimeState(Game.p2);
  UI.power1.textContent = '—';
  UI.power2.textContent = '—';

  ensureAudio();
  Game.started=true;

  reseedSession(1);

  Game.showStartHint = 240;
  resetMatch(true);
  updateLeaderHUD();
  UI.diff.textContent=SelectedDifficulty.name;
}


/* =================== BIOMES, ARBRES (EMOJI) & GÉNÉRATION =================== */
const BIOMES=[
  {name:'Forêt humide', sky1:'#2c1f35', sky2:'#0d0a12', moss:'#3fbf7f', soil:'#3b2a21', fog:'#ffffff0f', wall:'#3a2e43', deco:'#95e8b6'},
  {name:'Clairière dorée', sky1:'#4a2b1a', sky2:'#1a0e08', moss:'#ffd166', soil:'#5a3b2b', fog:'#ffd1660f', wall:'#5a3b2b', deco:'#ffd98a'},
  {name:'Sous-bois bleuté', sky1:'#203248', sky2:'#0a0f16', moss:'#64d7ff', soil:'#2b303a', fog:'#64d7ff12', wall:'#314459', deco:'#9fe4ff'},
  {name:'Mousse émeraude', sky1:'#153022', sky2:'#08120c', moss:'#2fd07a', soil:'#1c2a21', fog:'#2fd07a12', wall:'#1e3a2f', deco:'#4ef1a8'}
];
let LEVEL_INDEX=0; let BIOME=BIOMES[0];

function mulberry32(seed){ let a=(seed>>>0)||0x9E3779B9; return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
function isGridShape(grid,c,r){ if(!Array.isArray(grid)||grid.length!==r) return false; for(let y=0;y<r;y++){ if(!Array.isArray(grid[y])||grid[y].length!==c) return false; } return true; }
function genLevel(seed){ const rng=mulberry32(seed==null? (Math.random()*1e9)|0:seed); let maze=createMaze(COLS,ROWS,rng); if(!isGridShape(maze,COLS,ROWS)) maze=createMaze(COLS,ROWS,mulberry32(0xDEADBEEF)); decorateMaze(maze,rng); return maze; }
function createMaze(w,h,rng){
  w=Math.max(5,w|0); h=Math.max(5,h|0);
  const g=Array.from({length:h},()=>Array.from({length:w},()=>1));
  const stack=[]; const start=[1,1]; g[1][1]=0; stack.push(start);
  const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
  while(stack.length){
    const last=stack[stack.length-1]; const cx=last[0], cy=last[1];
    for(let i=dirs.length-1;i>0;i--){ const j=(rng()*(i+1))|0; const tmp=dirs[i]; dirs[i]=dirs[j]; dirs[j]=tmp; }
    let carved=false;
    for(let d=0;d<dirs.length;d++){
      const dx=dirs[d][0], dy=dirs[d][1]; const nx=cx+dx, ny=cy+dy;
      if(nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
      if(g[ny][nx]===1){ g[cy+dy/2][cx+dx/2]=0; g[ny][nx]=0; stack.push([nx,ny]); carved=true; break; }
    }
    if(!carved) stack.pop();
  }
  for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(g[y][x]===0) g[y][x]=2; // spores
  for(let x=0;x<w;x++){ g[0][x]=1; g[h-1][x]=1;}
  for(let y=0;y<h;y++){ g[y][0]=1; g[y][w-1]=1;}
  return g;
}
function decorateMaze(g, rng){
  if(!Array.isArray(g)||!g.length||!Array.isArray(g[0])) return g;
  const h=g.length,w=g[0].length;

  // Élargissements locaux connectés (pas de "salles" isolées)
  const holes = ((w*h)/180)|0; // ~proportion douce selon la taille
  for(let n=0;n<holes;n++){
    let tries=24;
    while(tries--){
      const x = 1 + ((rng()*(w-2))|0);
      const y = 1 + ((rng()*(h-2))|0);
      if (g[y][x]===1){
        // On ne transforme en 2 que si au moins un voisin est déjà ouvert
        if (g[y][x-1]===2 || g[y][x+1]===2 || g[y-1][x]===2 || g[y+1][x]===2){
          g[y][x]=2;
          break;
        }
      }
    }
  }

   // Distribution aléatoire mais bornée de bonus/pièges ...
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      if(g[y][x]===2){
        const r=rng();
        if(r<0.03) g[y][x]=4;       // piège
        else if(r<0.08) g[y][x]=3;  // bonus
      }
    }
  }

  // --- AJOUT : petites placettes aléatoires (garanties connectées)
  // --- paramètres ADAPTATIFS en fonction de la carte ---
const area   = w * h;
const minDim = Math.min(w, h);

// tailles (demi-axes), bornées
const halfMin = Math.max(1, Math.min(4, (minDim * 0.02) | 0));
const halfMax = Math.max(halfMin + 1, Math.min(6, (minDim * 0.06) | 0));

// quantités, croissent avec l'aire, bornées
const countMin = Math.max(2, Math.min(8,  (area / 1500) | 0));
const countMax = Math.max(countMin + 1, Math.min(12, (area /  900) | 0));

// appel avec paramètres adaptatifs
carveRandomPlacettes(g, rng, countMin, countMax, halfMin, halfMax);

  return g;
}


// Ouvre N petites "placettes" (salles) rectangulaires, tailles variables, connectées aux couloirs existants.
// g : grille (0..4/5), rng : PRNG mulberry32
function carveRandomPlacettes(g, rng, countMin=2, countMax=5, halfMin=1, halfMax=3) {
  const H = g.length|0; if (H<=0) return g;
  const W = (g[0]||[]).length|0; if (W<=0) return g;

  // utilitaires
  const inb = (x,y)=> (x>1 && y>1 && x<W-2 && y<H-2);
  const open = (x,y)=>{ if (inb(x,y) && g[y][x]===1) g[y][x]=2; };

  // nombre de placettes aléatoire
  const nPlac = Math.max(countMin, Math.min(countMax, (countMin + ((rng()*(countMax-countMin+1))|0)) ));

  // essaie de partir d'une case déjà ouverte (2) pour garantir la connexion
  function pickOpen() {
    for (let tries=0; tries<200; tries++){
      const x = 2 + ((rng()*(W-4))|0);
      const y = 2 + ((rng()*(H-4))|0);
      if (g[y][x] === 2) return {x,y};
    }
    // fallback : on en crée une petite au hasard
    return { x: (W/2)|0, y: (H/2)|0 };
  }

  for (let k=0; k<nPlac; k++){
    const seed = pickOpen();
    const hx = Math.max(halfMin, Math.min(halfMax, (halfMin + ((rng()*(halfMax-halfMin+1))|0)) ));
    const hy = Math.max(halfMin, Math.min(halfMax, (halfMin + ((rng()*(halfMax-halfMin+1))|0)) ));

    // centre légèrement bruité depuis la seed
    const cx = Math.max(2, Math.min(W-3, seed.x + (((rng()*3)|0)-1) ));
    const cy = Math.max(2, Math.min(H-3, seed.y + (((rng()*3)|0)-1) ));

    // on ouvre un rectangle (cx-hx..cx+hx , cy-hy..cy+hy)
    for (let y=cy-hy; y<=cy+hy; y++){
      for (let x=cx-hx; x<=cx+hx; x++){
        open(x,y);
      }
    }

    // petite “respiration” vers l’extérieur pour éviter les salles trop fermées
    open(cx-hx-1, cy); open(cx+hx+1, cy);
    open(cx, cy-hy-1); open(cx, cy+hy+1);

    // éventuellement arrondir un peu les coins (option doux)
    if (rng() < 0.5) open(cx-hx, cy-hy-1);
    if (rng() < 0.5) open(cx+hx, cy-hy-1);
    if (rng() < 0.5) open(cx-hx, cy+hy+1);
    if (rng() < 0.5) open(cx+hx, cy+hy+1);
  }

  return g;
}



/* ============ État jeu ============ */
const Game={
  started:false, mode:'solo',
  grid:null, remaining:0,
  score1:0, score2:0, lives1:3, lives2:3,
  paused:false, countdown:0,
  traps:[], bonuses:[], parasites:[], particles:[], vortexes:[], 
  muscariaTrap1:null, muscariaTrap2:null,
  p1:null, p2:null,
  servant1:null, servant2:null,
  blindGlobal:0,
  levelsToPlay: MATCH_LEVELS_SOLO,
  girollePanic:{active:false, ownerPid:0},
  showStartHint: 0,
  themeLayer:null, wallsLayer:null, pelletsLayer:null,
  vortexBlocks:[]
};

function gridDims(){ const rows=Array.isArray(Game.grid)?Game.grid.length:0; const cols=rows>0 && Array.isArray(Game.grid[0])?Game.grid[0].length:0; return {cols,rows}; }

/* =================== VORTEX : placement proche des angles + carving =================== */

// Carve "croix" douce autour du vortex pour élargir légèrement le passage
function carvePlus(x, y) {
  const dm = gridDims(); const C=dm.cols, R=dm.rows;
  const open = (tx,ty)=>{
    if (tx>0 && ty>0 && tx<C-1 && ty<R-1) {
      if (Game.grid[ty][tx] === 1) Game.grid[ty][tx] = 2; // 2 = ouvert (spore)
    }
  };

  // anneau immédiat (3x3) — on n'ouvre PAS le centre, il restera VORTEX
  for (let dy=-1; dy<=1; dy++){
    for (let dx=-1; dx<=1; dx++){
      if (dx===0 && dy===0) continue; // centre = vortex
      open(x+dx, y+dy);
    }
  }

  // petite respiration supplémentaire sur les 4 axes
  open(x-2, y);
  open(x+2, y);
  open(x, y-2);
  open(x, y+2);
}

// Cherche une case ouverte proche d’un angle, sinon on “perce” un peu
function pickNearCorner(corner) {
  // corner: 'tl' | 'tr' | 'bl' | 'br'
  const dm = gridDims(); const C=dm.cols, R=dm.rows;
  const pad = Math.max(3, Math.floor(Math.min(C,R)*0.12)); // zone angulaire
  let x0 = (corner==='tl'||corner==='bl') ? 1 : Math.max(1, C-pad-1);
  let y0 = (corner==='tl'||corner==='tr') ? 1 : Math.max(1, R-pad-1);
  const x1 = (corner==='tl'||corner==='bl') ? Math.min(C-2, 1+pad) : C-2;
  const y1 = (corner==='tl'||corner==='tr') ? Math.min(R-2, 1+pad) : R-2;

  // 1) tente une case déjà ouverte (2)
  for (let tries=0; tries<400; tries++){
    const x = x0 + ((Math.random()*(x1-x0+1))|0);
    const y = y0 + ((Math.random()*(y1-y0+1))|0);
    if (Game.grid[y] && Game.grid[y][x]===2) return {x,y};
  }
  // 2) sinon, on perce légèrement depuis la bordure vers l’intérieur
  for (let tries=0; tries<400; tries++){
    const x = x0 + ((Math.random()*(x1-x0+1))|0);
    const y = y0 + ((Math.random()*(y1-y0+1))|0);
    if (Game.grid[y] && Game.grid[y][x]===1) {
      // Perce uniquement si un voisin est ouvert, pour rester connecté
      if (Game.grid[y][x-1]===2 || Game.grid[y][x+1]===2 || Game.grid[y-1]?.[x]===2 || Game.grid[y+1]?.[x]===2) {
        Game.grid[y][x]=2; // devient ouvert
        return {x,y};
      }
    }
  }
  // 3) fallback sûr
  return findOpenTile();
}

// Place 4 vortex (un par angle), marque la case comme VORTEX, élargit localement et stocke
function placeVortexes(){
  Game.vortexes = [];
  const corners = ['tl','tr','bl','br'];
  for (const c of corners){
    const pos = pickNearCorner(c);
    // centre = vortex (pas de spore)
    Game.grid[pos.y][pos.x] = VORTEX;
    carvePlus(pos.x, pos.y);
    Game.vortexes.push({x:pos.x, y:pos.y});
  }
}

function randomOtherVortexIndex(fromIdx){
  if(!Array.isArray(Game.vortexes) || Game.vortexes.length<2) return fromIdx;
  let idx = fromIdx;
  while (idx===fromIdx) idx = (Math.random()*Game.vortexes.length)|0;
  return idx;
}

function teleportEntityToOtherVortex(entity, fromGX, fromGY){
  if(!Game.vortexes || Game.vortexes.length<2) return;
  let fromIdx = Game.vortexes.findIndex(v=>v.x===fromGX && v.y===fromGY);
  if(fromIdx<0) fromIdx = 0;
  const toIdx = randomOtherVortexIndex(fromIdx);
  const target = Game.vortexes[toIdx];
  
// Blocus 5s du vortex d'arrivée
addVortexBlock(target.x, target.y, 300);
  
  entity.x = target.x + 0.5;
  entity.y = target.y + 0.5;
  entity.dir = [0,0];

  // anti-boucle
  entity.tpGrace = 20; // ~0.33 s

  // si parasite (pas de pid) -> décale hors du vortex + évite 2 s
if (entity && typeof entity.pid !== 'number') {
  const opts = neighborsForParasite(target.x, target.y);
  if (opts.length){
    const pick = opts[(Math.random()*opts.length)|0];
    entity.x = pick[0] + 0.5;
    entity.y = pick[1] + 0.5;
  }
  entity.avoidVortex = 120; // ~2 s
}

  // --- AJOUT : si c'est un JOUEUR (possède pid), on déclenche spin + glow 2s
  if (entity && typeof entity.pid === 'number') {
    entity.spinTimer = 120; // 2s @60fps
    entity.glowTimer = 120;
  }

  // petit effet visuel
  Game.particles.push({x:(target.x*TILE), y:(target.y*TILE), r:0, life:120, type:'cloud'});
}
  
function resetMatch(full){
  full=!!full;
  Game.score1=0; Game.score2=0; Game.lives1=3; Game.lives2=3;
  LEVEL_INDEX=0;
  Game.levelsToPlay = 1;
  loadLevel(0,true);
  UI.mode.textContent=(Game.mode==='duo'?'2 Joueurs':'Solo');
  UI.p2hud.style.display=(Game.mode==='duo')?'':'none';
  Game.paused=true; Game.countdown=0;
  updateLeaderHUD();
}

function enemyBaseSpeedAt(levelIdx){
  // vitesse de base commune à l’init et au respawn
  return 0.09 + Math.min(0.1, levelIdx * 0.01);
}
  
function loadLevel(i,first=false){
  BIOME=BIOMES[i%BIOMES.length];
const seed = (SESSION_SEEDS[i] ?? ((Math.random()*1e9)|0)) + (i*101);
Game.grid = genLevel(seed);
  Game.traps=[]; Game.bonuses=[]; Game.parasites=[]; Game.particles=[];
  Game.muscariaTrap1=null; Game.muscariaTrap2=null; Game.remaining=0;
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;

  for(let y=0;y<rows;y++){
    const row=Game.grid[y];
    for(let x=0;x<cols;x++){
      const v=row[x];
      if(v===2) Game.remaining++;
      if (v===3) {
  const k = (i + y + x) % BonusKinds.length;
  Game.bonuses.push({ x, y, kind: pickBonusKind(k) });
}
      if(v===4) Game.traps.push({x,y,t:(i+x+y)%2});
    }
  }

  placeVortexes();
  
  const count= (6+Math.floor(i*0.8));
  for(let k=0;k<count;k++){
    const pos=findOpenTile();
const base = enemyBaseSpeedAt(i);
const speed = base * SelectedDifficulty.factor;
    Game.parasites.push({
      x:pos.x+0.5,y:pos.y+0.5,dir:[1,0],speed:speed,baseSpeed:speed,kind:k%4,
      scared:0, blind:0,
      state:'wander',lastSeen:null,path:[],
      chaos:false, chaosMode:null, chaosTick:0, chaosTarget:null,
      seedOnce:false, seedCd:0, chaosAte:false,
      servant:false, frozen: 0, servantTime:0, servantOwner:0,
      // knockback
      kbActive:false, kbTx:0, kbTy:0, kbSpeed:0, kbDir:[0,0],
      // confusion (après impact mur)
      fleeGirolle:0,
      morilleChaos:0, morilleOwner:0, morilleNextSwitch:0, morilleMode:null,
      confusedTimer:0,
      tpGrace:0,
      avoidVortex: 0  // frames à éviter de repasser sur un vortex
    });
  }

  // joueurs — positions de départ vraiment aléatoires
  const p1pos = findOpenTile();
  let p2pos = null;
  if (Game.mode==='duo'){
    // essaie d'éloigner les spawns (≈ la moitié de la petite dimension)
    const dm=gridDims();
    const minD = Math.max(6, Math.min(dm.cols, dm.rows)/2|0);
    p2pos = findOpenTileFarFrom(p1pos, minD);
  }

  if(first){
    Game.p1 = makePlayer(p1pos.x, p1pos.y, 1, Selected1);
    if(Game.mode==='duo'){ Game.p2 = makePlayer(p2pos.x, p2pos.y, 2, Selected2); }
  }else{
    Game.p1.x = p1pos.x+0.5; Game.p1.y = p1pos.y+0.5; Game.p1.dir=[0,0];
    if(Game.mode==='duo' && Game.p2){
      Game.p2.x = p2pos.x+0.5; Game.p2.y = p2pos.y+0.5; Game.p2.dir=[0,0];
    }
  }

  // --- RESET des effets temporaires à chaque début de niveau
resetPlayerTransientForNewLevel(Game.p1);
if (Game.mode === 'duo' && Game.p2) resetPlayerTransientForNewLevel(Game.p2);

// Nettoie les libellés pouvoirs dans le HUD
UI.power1.textContent = '—';
if (Game.mode === 'duo') UI.power2.textContent = '—';

  buildLayers();
  UI.lvl.textContent=(i+1);
  UI.score1.textContent=Game.score1; UI.lives1.textContent=Game.lives1; UI.power1.textContent='—';
  UI.score2.textContent=Game.score2; UI.lives2.textContent=Game.lives2; UI.power2.textContent='—';
  UI.diff.textContent=SelectedDifficulty.name;
  Game.paused=true; Game.countdown=0;
  updateLeaderHUD();
}

function makePlayer(tx,ty,pid,species){
  return { pid, species, x:tx+0.5, y:ty+0.5, dir:[0,0], nextDir:[0,0], speed:0.11, size:0.9,
    powerTimer:0, invisible:false, speedBoost:1, spinning:false, shield:false, phase:false,
    frozenTimer:0, anim:0, nextPowerExtend:0, girolleTrapImmune:false, phaseCooldown:0, phaseInsideWall:false, hunterWindow:0, trumpetTrapImmune:false,
    respawnFlash: 0, hitGrace: 0, tpGrace: 0, spinTimer: 0, spinPhase: 0, glowTimer: 0, invulnTimer: 0, collectedSpores:0,
    trumpetCd:0
  };
}

  // --- RESET ÉTATS TEMPORAIRES AU DÉBUT D'UN NOUVEAU NIVEAU ---
// (ne touche pas aux compteurs long-terme comme collectedSpores)
function resetPlayerTransientForNewLevel(pl){
  if(!pl) return;
  // Effets de pouvoir en cours
  pl.powerTimer = 0;
  pl.invisible  = false;
  pl.speedBoost = 1;
  pl.shield     = false;

  // Phalloïde
  pl.phase = false;
  pl.phaseInsideWall = false;
  pl.phaseCooldown   = 0;

  // Girolle
  pl.hunterWindow = 0;
  pl.invulnTimer  = 0;

  // Trompette
  pl.trumpetCd = 0;              // on remet le CD à 0 entre niveaux
  pl.trumpetTrapImmune = false;

  // Divers runtime
  pl.hitGrace = 0;
  pl.frozenTimer = 0;
  pl.respawnFlash = 0;
  pl.spinTimer = 0;
  pl.spinPhase = 0;
  pl.glowTimer = 0;
  pl.tpGrace = 0;
  pl.nextPowerExtend = 0;

  // IMPORTANT : on NE remet PAS pl.collectedSpores ici
}


function resetPlayerRuntimeState(pl){
  if(!pl) return;
  // états de pouvoir / temps
  pl.powerTimer = 0;
  pl.invisible  = false;
  pl.speedBoost = 1;
  pl.shield     = false;

  // Phalloïde
  pl.phase = false;
  pl.phaseInsideWall = false;
  pl.phaseCooldown   = 0;

  // Girolle
  pl.hunterWindow = 0;
  pl.invulnTimer  = 0;

  // Trompette
  pl.trumpetCd = 0;
  pl.trumpetTrapImmune = false;
  pl.collectedSpores   = 0;   // <<< durée potentielle = 0 s

  // Divers runtime
  pl.hitGrace = 0;
  pl.frozenTimer = 0;
  pl.respawnFlash = 0;
  pl.spinTimer = 0;
  pl.spinPhase = 0;
  pl.glowTimer = 0;
  pl.tpGrace = 0;
  pl.nextPowerExtend = 0;
}
  

function findOpenTile(){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; for(let t=0;t<4000;t++){ const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0; if(Game.grid[y]&&Game.grid[y][x]===2) return {x,y}; } return {x:1,y:1}; }
function findOpenTileFarFrom(ref, minD){
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;
  const minDist = Math.max(2, minD|0);
  for(let t=0;t<4000;t++){
    const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0;
    if(Game.grid[y] && Game.grid[y][x]===2){
      const d = Math.abs(x-ref.x)+Math.abs(y-ref.y); // distance de Manhattan
      if(d>=minDist) return {x,y};
    }
  }
  return findOpenTile();
}
function findOpenNear(cx,cy){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; const maxR=Math.max(cols,rows); for(let r=0;r<maxR;r++){ for(let dy=-r;dy<=r;dy++){ for(let dx=-r;dx<=r;dx++){ const x=cx+dx,y=cy+dy; if(x>=1&&y>=1&&x<cols-1&&y<rows-1){ if(Game.grid[y]&&Game.grid[y][x]===2) return {x,y}; } } } } return findOpenTile(); }
function spawnEnemy(){ const pos=findOpenTile(); const base = enemyBaseSpeedAt(LEVEL_INDEX);
const speed = base * SelectedDifficulty.factor; const kind=(Math.random()*4)|0;
  Game.parasites.push({
    x:pos.x+0.5,y:pos.y+0.5,dir:[1,0],speed:speed,baseSpeed:speed,kind,
    scared:0,blind:0,state:'wander',lastSeen:null,path:[],
    chaos:false,chaosMode:null,chaosTarget:null,seedOnce:false,seedCd:0,chaosAte:false,
    servant:false,servantTime:0,servantOwner:0,
    kbActive:false,kbTx:0,kbTy:0,kbSpeed:0,kbDir:[0,0],
    fleeGirolle:0, frozen: 0,
    morilleChaos:0, morilleOwner:0, morilleNextSwitch:0, morilleMode:null, tpGrace:0,
    confusedTimer:0, avoidVortex: 0  // frames à éviter de repasser sur un vortex
  });
}

/* Bonus & spores */
const BonusKinds=['life','speed','power','score','freeze'];
  // --- Tuile vortex ---
const VORTEX = 5; // case spéciale vortex (walkable, sans spore)
function pickBonusKind(seed){ return BonusKinds[seed%BonusKinds.length]; }
function spawnSporeCloud(x,y,radTiles=null){
  Game.particles.push({x:x*TILE,y:y*TILE,r:0,life:240,type:'cloud'});
  if (radTiles!=null) {
    Game.parasites.forEach(p=>{
      if (Math.hypot(p.x-x, p.y-y) <= radTiles) p.scared = 200;
    });
  }
}


/* ---------- Repousse radial (fallback) ---------- */
function repelEnemiesAround(pl, radiusTiles, forceTiles){
  const radius = radiusTiles;
  const force  = forceTiles;
  const px = pl.x, py = pl.y;

  Game.parasites.forEach(p=>{
    const dx = p.x - px, dy = p.y - py;
    const dist = Math.hypot(dx,dy);
    if(dist > 0 && dist <= radius){
      const nx = dx / dist, ny = dy / dist;
      p.x += nx * force;
      p.y += ny * force;
      p.scared = Math.max(p.scared, 120);
      p.path = [];
      p.lastSeen = null;
    }
  });
}

/* ---------- Knockback (Cèpe) + effet domino ---------- */
// calcule la cible mur depuis p en suivant le vecteur depuis pl -> p
function computeKnockbackTarget(p, pl){
  let dx = p.x - pl.x, dy = p.y - pl.y;
  const len = Math.hypot(dx, dy) || 1;
  dx /= len; dy /= len;
  return computeKnockbackTargetDir({x:p.x, y:p.y}, [dx,dy]);
}
// calcule la cible mur depuis origin (obj {x,y} en cases) dans la direction dir ([dx,dy] normalisé)
function computeKnockbackTargetDir(origin, dir){
  const step = 0.2;
  const maxSteps = 220;
  let lastX = origin.x, lastY = origin.y;
  const dx = dir[0], dy = dir[1];
  for(let i=0;i<maxSteps;i++){
    const nx = lastX + dx * step;
    const ny = lastY + dy * step;
    const gx = Math.floor(nx), gy = Math.floor(ny);
    if(!isWalkable(gx, gy)){
      break; // le prochain pas tape un mur -> on s'arrête juste avant
    }
    lastX = nx; lastY = ny;
  }
  return { x:lastX, y:lastY };
}

/* Couches graphiques */
function buildLayers(){
  const theme=makeLayerCanvas(W,H), tctx=theme.getContext('2d');
  const g=tctx.createLinearGradient(0,0,0,H); g.addColorStop(0,BIOME.sky1); g.addColorStop(1,BIOME.sky2);
  tctx.fillStyle=g; tctx.fillRect(0,0,W,H);
  for(let i=0;i<60;i++){ tctx.globalAlpha=0.08; tctx.beginPath(); tctx.arc(Math.random()*W,Math.random()*H,10+Math.random()*30,0,6.28); tctx.fillStyle=BIOME.fog; tctx.fill(); }
  Game.themeLayer=theme;

  const walls=makeLayerCanvas(W,H), wctx=walls.getContext('2d');
  const pellets=makeLayerCanvas(W,H), pctx=pellets.getContext('2d');
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows;
  for(let y=0;y<rows;y++){
    const row=Game.grid[y];
    for(let x=0;x<cols;x++){
      if(row[x]===1) drawWallCell(wctx,x,y);    // <-- murs + emoji
      if(row[x]===2) drawPellet(pctx,x,y);
    }
  }
  Game.wallsLayer=walls; Game.pelletsLayer=pellets;
}
function drawWallCell(ctx, x, y) {
  const px = x * TILE, py = y * TILE;

  const path = pickTreeSpriteAt(x, y);
  const img  = loadImg(path);

  // On déborde de 1px de chaque côté : -1, +2
  const bleed = 1;
  const ox = px - bleed;
  const oy = py - bleed;
  const S  = TILE + bleed * 2;

  if (img.complete) {
    ctx.drawImage(img, ox, oy, S, S);
  } else {
    img.addEventListener('load', () => ctx.drawImage(img, ox, oy, S, S), { once:true });
  }
}



function drawPellet(ctx,x,y){ const px=x*TILE+TILE/2, py=y*TILE+TILE/2; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(px,py,3,0,6.28); ctx.fill(); }

/* =================== IA, GAMEPLAY & RENDU =================== */
function dims(){ const dm=gridDims(); return {C:dm.cols,R:dm.rows}; }
function openTile(tx,ty,pl){ const d=dims(); if(!Game.grid||ty<0||tx<0||ty>=d.R||tx>=d.C) return false; const v=Game.grid[ty][tx]; if(v===1){ if(pl&&pl.phase){ if(tx===0||ty===0||tx===d.C-1||ty===d.R-1) return false; return true; } return false; } if(v===VORTEX && isVortexBlocked(tx,ty)) return false; return true; }
function isWalkable(tx,ty){
  const d=dims();
  if(tx<0||ty<0||tx>=d.C||ty>=d.R) return false;
  const v = Game.grid[ty][tx];
  if(v===1) return false;
  if(v===VORTEX && isVortexBlocked(tx,ty)) return false;
  return true;
}
function neighbors(tx,ty){ return [[1,0],[-1,0],[0,1],[0,-1]].map(d=>[tx+d[0],ty+d[1]]).filter(p=>isWalkable(p[0],p[1])); }
function isVortex(tx, ty){
  return !!(Game.grid[ty] && Game.grid[ty][tx] === VORTEX);
}
function isVortexBlocked(tx, ty){
  return Game.vortexBlocks.some(b => b.x===tx && b.y===ty && b.timer>0);
}
function addVortexBlock(tx, ty, frames=300){
  // remplace si déjà présent
  const i = Game.vortexBlocks.findIndex(b=>b.x===tx && b.y===ty);
  if(i>=0) Game.vortexBlocks[i].timer = Math.max(Game.vortexBlocks[i].timer, frames);
  else Game.vortexBlocks.push({x:tx, y:ty, timer:frames});
}
function isWalkableForParasite(tx, ty){
  // Un parasite considère un vortex comme “mur mou” pour l’itinéraire
  return isWalkable(tx,ty) && !isVortex(tx,ty);
}
function neighborsForParasite(tx,ty){
  return [[1,0],[-1,0],[0,1],[0,-1]]
    .map(d=>[tx+d[0],ty+d[1]])
    .filter(p=>isWalkableForParasite(p[0],p[1]));
}
function bfsParasite(start, goal){
  const key=(x,y)=>x+','+y;
  // Si la cible est un vortex, vise un voisin non-vortex
  if(isVortex(goal[0],goal[1])){
    const ns = neighborsForParasite(goal[0],goal[1]);
    if(ns.length) goal = ns[0];
  }
  if(!isWalkableForParasite(goal[0],goal[1])) return [];
  const q=[start];
  const came=new Map(); came.set(key(start[0],start[1]), null);
  while(q.length){
    const node=q.shift(); const x=node[0], y=node[1];
    if(x===goal[0]&&y===goal[1]) break;
    const ns=neighborsForParasite(x,y);
    for(let i=0;i<ns.length;i++){
      const nx=ns[i][0], ny=ns[i][1]; const k=key(nx,ny);
      if(!came.has(k)){ came.set(k,[x,y]); q.push([nx,ny]); }
    }
  }
  const path=[]; let cur=goal; const sKey=key(start[0],start[1]);
  while(cur && key(cur[0],cur[1])!==sKey){
    const prev=came.get(key(cur[0],cur[1])); if(!prev) break;
    path.push(cur); cur=prev;
  }
  path.reverse(); return path;
}
function bfs(start,goal){ const key=(x,y)=>x+','+y; if(!isWalkable(goal[0],goal[1])) return []; const q=[start]; const came=new Map(); came.set(key(start[0],start[1]), null); while(q.length){ const node=q.shift(); const x=node[0], y=node[1]; if(x===goal[0]&&y===goal[1]) break; const ns=neighbors(x,y); for(let i=0;i<ns.length;i++){ const nx=ns[i][0], ny=ns[i][1]; const k=key(nx,ny); if(!came.has(k)){ came.set(k,[x,y]); q.push([nx,ny]); } } } const path=[]; let cur=goal; const sKey=key(start[0],start[1]); while(cur && key(cur[0],cur[1])!==sKey){ const prev=came.get(key(cur[0],cur[1])); if(!prev) break; path.push(cur); cur=prev; } path.reverse(); return path; }
function sameRowOrCol(a,b){ return a[0]===b[0] || a[1]===b[1]; }
function hasLineOfSight(a,b){ if(!sameRowOrCol(a,b)) return false; const ax=a[0], ay=a[1], bx=b[0], by=b[1]; if(ax===bx){ const min=Math.min(ay,by), max=Math.max(ay,by); for(let y=min+1;y<max;y++){ if(Game.grid[y][ax]===1) return false; } return true; } else { const min=Math.min(ax,bx), max=Math.max(ax,bx); for(let x=min+1;x<max;x++){ if(Game.grid[ay][x]===1) return false; } return true; } }
function randomOpenTile(){ const dm=gridDims(); const cols=dm.cols, rows=dm.rows; for(let t=0;t<2000;t++){ const x=(Math.random()*cols)|0, y=(Math.random()*rows)|0; if(isWalkable(x,y)) return [x,y]; } return [1,1]; }
function findNearestPellet(from){
  const dm=gridDims(); const cols=dm.cols, rows=dm.rows; let best=null, bestD=1e9;
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){
    if(Game.grid[y][x]===2){ const d=Math.abs(x-from[0])+Math.abs(y-from[1]); if(d<bestD){ bestD=d; best=[x,y]; } }
  } return best;
}

/* Serviteur Girolle */
function convertToServant(p, ownerPid){
  p.servant=true; p.servantTime=900; p.servantOwner=ownerPid;
  p.scared=0; p.blind=0; p.path=[]; p.lastSeen=null; p.chaos=false; p.chaosMode=null; p.chaosTarget=null;
  if(ownerPid===1) Game.servant1=p; else Game.servant2=p;
}
function releaseServant(ownerPid){
  const s = ownerPid===1? Game.servant1 : Game.servant2;
  if(s){ s.servant=false; s.servantTime=0; s.servantOwner=0; if(ownerPid===1) Game.servant1=null; else Game.servant2=null; }
}

/* Bonus */
function eatBonusFor(player,b){
  Game.grid[b.y][b.x]=0;
  switch(b.kind){
    case 'life':
      if(player.pid===1){ Game.lives1++; UI.lives1.textContent=Game.lives1; } else { Game.lives2++; UI.lives2.textContent=Game.lives2; }
      sfxLife(); break;
    case 'speed':
      player.speed*=1.4; setTimeout(()=>{ player.speed/=1.4; },6000); sfxPower(); break;
    case 'power':
      player.nextPowerExtend=(player.nextPowerExtend||0)+120; // +2s
      (player.pid===1?UI.power1:UI.power2).textContent='★ prêt (+2s)'; sfxPower();
      break;
    case 'score':
      if(player.pid===1){ Game.score1+=500; UI.score1.textContent=Game.score1; }
  else { Game.score2+=500; UI.score2.textContent=Game.score2; }
  updateLeaderHUD();
  sfxPower();
  break;
    case 'freeze':
  // immobilise brièvement tout le monde (~3s)
  Game.parasites.forEach(p => { p.frozen = Math.max(p.frozen||0, 180); });
  sfxPower();
  break;
  }
}
function refreshPelletCell(x,y){ if(!Game.pelletsLayer) return; const pctx=Game.pelletsLayer.getContext('2d'); pctx.clearRect(x*TILE,y*TILE,TILE,TILE); }

/* Entrées direction */
function inputDirFor(pid){
  if(pid===1){
    if(Keys['arrowup']) return [0,-1];
    if(Keys['arrowdown']) return [0,1];
    if(Keys['arrowleft']) return [-1,0];
    if(Keys['arrowright']) return [1,0];
  } else {
    if(Keys['z']) return [0,-1];
    if(Keys['s']) return [0,1];
    if(Keys['q']) return [-1,0];
    if(Keys['d']) return [1,0];
  }
  return [0,0];
}

/* Boucle principale */
let LAST=now();
function loop(){
  const t=now(); const dt=(t-LAST)/16.666; LAST=t;
  if(Game.countdown>0) updateCountdown();
  if(!Game.paused && Game.countdown===0) update(dt);
  draw();
  requestAnimationFrame(loop);
}
function startCountdown(frames){ Game.countdown=Math.max(1,frames|0); Game.paused=false; }
function updateCountdown(){
  Game.countdown--;
  if(Game.countdown<=0){
    Game.countdown=0;
    // --- AJOUT : lueur 2s pour le(s) joueur(s)
    if(Game.p1) Game.p1.glowTimer = Math.max(Game.p1.glowTimer||0, 120);
    if(Game.mode==='duo' && Game.p2) Game.p2.glowTimer = Math.max(Game.p2.glowTimer||0, 120);
  }
}


/* Update */
function update(dt){
  if(!Game.grid) return;

  updatePlayer(Game.p1, dt);
  if(Game.mode==='duo' && Game.p2) updatePlayer(Game.p2, dt);

  // Parasites
  Game.parasites.forEach((p,idx)=>{
    if (p.tpGrace>0) p.tpGrace--;
    if (p.avoidVortex>0) p.avoidVortex--;
    // --- Gel global (freeze bonus) : immobile mais toujours dangereux si on le touche
if (p.frozen > 0) {
  p.frozen--;
  // pas de déplacement ni d'IA, mais on conserve le check de collision:
  parasiteHitPlayers(p);
  return;
}

    // ---------- Knockback prioritaire + effet domino ----------
    if(p.kbActive){
      const dx = p.kbTx - p.x;
      const dy = p.kbTy - p.y;
      const dist = Math.hypot(dx, dy);
      const nx = (dist>0? dx/dist : 0), ny = (dist>0? dy/dist : 0);
      const spd = (p.kbSpeed || 0.22) * dt;
      p.kbDir = [nx,ny];
      if(dist <= 0.05){
        // Arrivé au mur -> confusion 3 s
        p.x = p.kbTx; p.y = p.kbTy;
        p.kbActive = false;
        p.confusedTimer = Math.max(p.confusedTimer, 180);
      } else {
        p.x += nx * spd;
        p.y += ny * spd;
        p.dir = [Math.sign(nx), Math.sign(ny)];

        // Collision avec d'autres parasites -> propulsion en ligne droite
        for(let j=0;j<Game.parasites.length;j++){
          if(j===idx) continue;
          const q = Game.parasites[j];
          if(q.kbActive || q.servant) continue;
          if(distance(p.x,p.y,q.x,q.y) < 0.55){
            // Propel q dans la même direction que p
            const tgt = computeKnockbackTargetDir(q, p.kbDir);
            q.kbActive = true;
            q.kbTx = tgt.x; q.kbTy = tgt.y;
            q.kbSpeed = Math.max(p.kbSpeed, q.speed*2);
            q.kbDir = [p.kbDir[0], p.kbDir[1]];
            q.path = []; q.lastSeen = null;
            q.scared = Math.max(q.scared, 90);
          }
        }
      }
      parasiteHitPlayers(p);
      return; // tant que knockback actif
    }

    // Confusion (après impact mur)
    if(p.confusedTimer>0){
      p.confusedTimer--;
      const eff = p.speed * dt * 0.4; // lent
      // petit erratisme
      if(Math.random()<0.25){
        const opts = neighborsForParasite(Math.floor(p.x), Math.floor(p.y));
        if(opts.length){
          const d=opts[(Math.random()*opts.length)|0];
          p.path = [[Math.floor(p.x)+d[0], Math.floor(p.y)+d[1]]];
        }
      }
      if(p.path && p.path.length){
        const tx=p.path[0][0]+0.5, ty=p.path[0][1]+0.5;
        const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
        p.x+=(dx/len)*eff; p.y+=(dy/len)*eff; p.dir=[Math.sign(dx),Math.sign(dy)];
        if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05) p.path.shift();
      }
      parasiteHitPlayers(p);
      return;
    }

    if(p.scared>0) p.scared--;
    if(p.blind>0) p.blind--;
    const eTile=[Math.max(0,Math.floor(p.x)), Math.max(0,Math.floor(p.y))];

// --- VORTEX : téléportation parasite ---
if (Game.grid[eTile[1]] && Game.grid[eTile[1]][eTile[0]] === VORTEX && !isVortexBlocked(eTile[0], eTile[1])) {
  if (!p.kbActive && p.tpGrace<=0) {
    teleportEntityToOtherVortex(p, eTile[0], eTile[1]);
    p.path=[]; p.lastSeen=null; // reset chemin
    return; // on ressort : la fonction de TP nous a déjà replacés
  }
  // Si on est dessus pendant la tpGrace, on “glisse” immédiatement sur un voisin non-vortex
  if (p.tpGrace>0) {
    const opts = neighborsForParasite(eTile[0], eTile[1]);
    if (opts.length){
      const [nx,ny] = opts[(Math.random()*opts.length)|0];
      const tx = nx+0.5, ty = ny+0.5;
      const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
      const spd = p.speed * dt * 1.2;
      p.x += (dx/len)*spd; p.y += (dy/len)*spd;
      p.dir=[Math.sign(dx),Math.sign(dy)];
      return;
    }
  }
}


    // pièges Amanite (si non serviteur)
    if(!p.servant){
      if(Game.muscariaTrap1 && Game.muscariaTrap1.active && eTile[0]===Game.muscariaTrap1.x && eTile[1]===Game.muscariaTrap1.y){
        const rt=randomOpenTile(); p.x=rt[0]+0.5; p.y=rt[1]+0.5; p.path=[]; p.lastSeen=null; p.chaosTarget=null;
      }
      if(Game.muscariaTrap2 && Game.muscariaTrap2.active && eTile[0]===Game.muscariaTrap2.x && eTile[1]===Game.muscariaTrap2.y){
        const rt=randomOpenTile(); p.x=rt[0]+0.5; p.y=rt[1]+0.5; p.path=[]; p.lastSeen=null; p.chaosTarget=null;
      }
    }

    // Fuite spécifique quand la Girolle a activé son pouvoir
if (Game.girollePanic.active && p.fleeGirolle > 0 && !p.servant) {
  p.fleeGirolle--;

  const owner = (Game.girollePanic.ownerPid === 1) ? Game.p1 : Game.p2;
  if (owner) {
    const eTile = [Math.floor(p.x), Math.floor(p.y)];
    let best = eTile, bestScore = -1;
    const ns = neighborsForParasite(eTile[0], eTile[1]);
    for (let i=0;i<ns.length;i++){
      const nx = ns[i][0], ny = ns[i][1];
      const dist = Math.hypot((nx+0.5)-owner.x, (ny+0.5)-owner.y);
      if (dist > bestScore) { bestScore = dist; best = ns[i]; }
    }
    const tx = best[0] + 0.5, ty = best[1] + 0.5;
    const dx = tx - p.x, dy = ty - p.y, len = Math.hypot(dx,dy)||1;
    const spd = p.speed * dt * 0.95;
    p.x += (dx/len)*spd; p.y += (dy/len)*spd;
    p.dir = [Math.sign(dx), Math.sign(dy)];
  }

  parasiteHitPlayers(p);
  return; // on court-circuite les autres IA (serviteur/aveugle/chaos/normal)
}

// --- CHAOS Morille (local et cadencé) ---
if (p.morilleChaos > 0) {
  p.morilleChaos--;
  p.morilleNextSwitch = (p.morilleNextSwitch||0) - 1;
  if (p.morilleNextSwitch <= 0 || !p.morilleMode) {
    // toutes les 5s (300 frames)
    p.morilleNextSwitch = 300;
    const modes = ['freeze','bounce','huntParasite','collect','rushPlayer'];
    p.morilleMode = modes[(Math.random()*modes.length)|0];
    p.chaosTarget = null;
  }

  const eTile=[Math.floor(p.x),Math.floor(p.y)];
  const base = p.speed*dt;
  const stepTo=(gx,gy,spd)=>{
    const tx=gx+0.5, ty=gy+0.5; const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
    p.x+=(dx/len)*spd; p.y+=(dy/len)*spd; p.dir=[Math.sign(dx),Math.sign(dy)];
    return (Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05);
  };

  if (p.morilleMode==='freeze') {
    // immobile
  }
  else if (p.morilleMode==='bounce') {
    // petits aller-retours
    if(!p.chaosTarget){
      const opts=[[1,0],[-1,0],[0,1],[0,-1]].filter(d=>isWalkable(eTile[0]+d[0], eTile[1]+d[1]));
      p.chaosTarget = opts.length ? [eTile[0]+opts[0][0], eTile[1]+opts[0][1]] : [eTile[0],eTile[1]];
    }
    const reached=stepTo(p.chaosTarget[0],p.chaosTarget[1], base*0.9);
    if(reached){
      const ox=eTile[0], oy=eTile[1];
      p.chaosTarget=[ox*2-p.chaosTarget[0], oy*2-p.chaosTarget[1]];
      if(!isWalkable(p.chaosTarget[0], p.chaosTarget[1])) p.chaosTarget=[ox,oy];
    }
  }
  else if (p.morilleMode==='huntParasite') {
    // attaquer le parasite le plus proche (repousse en ligne droite)
    let targetQ=null, best=1e9;
    for(const q of Game.parasites){ if(q===p) continue;
      const d = Math.hypot(q.x-p.x, q.y-p.y);
      if(d<best){ best=d; targetQ=q; }
    }
    const spd = base*1.2;
    if(targetQ){
      const dx=targetQ.x-p.x, dy=targetQ.y-p.y, len=Math.hypot(dx,dy)||1;
      p.x+=(dx/len)*spd; p.y+=(dy/len)*spd; p.dir=[Math.sign(dx),Math.sign(dy)];
      if(distance(p.x,p.y,targetQ.x,targetQ.y)<0.6){
        const tgt = computeKnockbackTargetDir(targetQ, [dx/len, dy/len]);
        targetQ.kbActive = true; targetQ.kbTx=tgt.x; targetQ.kbTy=tgt.y;
        targetQ.kbSpeed = Math.max(targetQ.speed*2, 0.22);
      }
    }
  }
  else if (p.morilleMode==='collect') {
    // aller chercher des spores pour le compte de la Morille (owner)
    const target=findNearestPellet([eTile[0],eTile[1]]);
    if(target){
      const reached=stepTo(target[0], target[1], base*1.05);
      if(reached){
        const gx=target[0], gy=target[1];
        if(Game.grid[gy] && Game.grid[gy][gx]===2){
          Game.grid[gy][gx]=0; Game.remaining--; sfxEat(); refreshPelletCell(gx,gy);
          if(p.morilleOwner===1){ Game.score1+=10; UI.score1.textContent=Game.score1; }
          else if(p.morilleOwner===2){ Game.score2+=10; UI.score2.textContent=Game.score2; }
          updateLeaderHUD();
        }
      }
    }
  }
  else if (p.morilleMode==='rushPlayer' && Game.mode==='duo') {
    // attaquer l'autre joueur avec vitesse x3
    const tgtPl = (p.morilleOwner===1)? Game.p2 : Game.p1;
    if(tgtPl){
      const dx=tgtPl.x-p.x, dy=tgtPl.y-p.y, len=Math.hypot(dx,dy)||1;
      const spd = base*3.0;
      p.x+=(dx/len)*spd; p.y+=(dy/len)*spd; p.dir=[Math.sign(dx),Math.sign(dy)];
    }
  }

  parasiteHitPlayers(p);
  return; // court-circuite le reste de l'IA pour ce parasite
}
    
    // Serviteur : collecte
    if(p.servant){
      p.servantTime--; if(p.servantTime<=0){ p.servant=false; if(p.servantOwner===1 && Game.servant1===p) Game.servant1=null; if(p.servantOwner===2 && Game.servant2===p) Game.servant2=null; }
      const target=findNearestPellet([Math.floor(p.x),Math.floor(p.y)]);
      const effspd=p.speed*dt*1.05;
      if(target){
        const tx=target[0]+0.5, ty=target[1]+0.5;
        const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
        p.x+=(dx/len)*effspd; p.y+=(dy/len)*effspd; p.dir=[Math.sign(dx),Math.sign(dy)];
        if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05){
          const gx=target[0], gy=target[1];
          if(Game.grid[gy] && Game.grid[gy][gx]===2){
            Game.grid[gy][gx]=0; Game.remaining--; sfxEat(); refreshPelletCell(gx,gy);
            if(p.servantOwner===1){ Game.score1+=10; UI.score1.textContent=Game.score1; } else if(p.servantOwner===2){ Game.score2+=10; UI.score2.textContent=Game.score2; }
            updateLeaderHUD();
          }
        }
      }
      parasiteHitPlayers(p);
      return;
    }

    // Aveugle : errance lente
if(p.blind>0){
  const eff=p.speed*dt*0.25; // très lent
  // direction aléatoire plus fréquente
  if(!p.path || p.path.length===0 || Math.random()<0.45){
    const opts = neighborsForParasite(eTile[0], eTile[1]);
    if (opts.length) {
  const id = (Math.random()*opts.length)|0;
  p.path = [[eTile[0]+opts[id][0], eTile[1]+opts[id][1]]];
} else {
  p.path = [];
}
  }
  if(p.path && p.path.length){
    const tx=p.path[0][0]+0.5, ty=p.path[0][1]+0.5;
    const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1;
    p.x+=(dx/len)*eff; p.y+=(dy/len)*eff; p.dir=[Math.sign(dx),Math.sign(dy)];
    if(Math.abs(p.x-tx)<0.05 && Math.abs(p.y-ty)<0.05) p.path.shift();
  }
  parasiteHitPlayers(p);
  return;
}

   // normal
    p.chaos=false; p.chaosMode=null; p.chaosTarget=null;

    // cible : joueur visible le plus proche/aligné
    const p1=Game.p1, p2=(Game.mode==='duo'?Game.p2:null);
    const eTile1=[Math.floor(p1.x),Math.floor(p1.y)];
    let target=null;
    const sees1 = !p1.invisible && (hasLineOfSight(eTile, eTile1) || (Math.abs(eTile[0]-eTile1[0])+Math.abs(eTile[1]-eTile1[1])<=6));
    if(sees1) target=eTile1;
    if(p2 && !p2.invisible){
      const eTile2=[Math.floor(p2.x),Math.floor(p2.y)];
      const sees2 = hasLineOfSight(eTile, eTile2) || (Math.abs(eTile[0]-eTile2[0])+Math.abs(eTile[1]-eTile2[1])<=6);
      if(sees2){
        const d1=target? (Math.abs(eTile[0]-target[0])+Math.abs(eTile[1]-target[1])) : 1e9;
        const d2= Math.abs(eTile[0]-eTile2[0])+Math.abs(eTile[1]-eTile2[1]);
        if(d2<d1) target=eTile2;
      }
    }

if (target) {
  p.state = 'chase';
  p.lastSeen = [target[0], target[1]];
  p.path = bfsParasite(eTile, target);
} else if (p.lastSeen) {
  if (eTile[0] === p.lastSeen[0] && eTile[1] === p.lastSeen[1]) {
    p.lastSeen = null;
    p.state = 'search';
    p.target = randomOpenTile();
    p.path = bfsParasite(eTile, p.target);
  } else {
    p.state = 'search';
    p.path = bfsParasite(eTile, p.lastSeen);
  }
} else {
  if (!p.path || p.path.length === 0) {
    p.state = 'wander';
    p.target = randomOpenTile();
    p.path = bfsParasite(eTile, p.target);
  }
}

// Fallback : s'il n'y a toujours aucun chemin, avancer vers un voisin valable (hors vortex)
if (!p.path || p.path.length === 0) {
  const opts = neighborsForParasite(eTile[0], eTile[1]);
  if (opts.length) {
    const [nx, ny] = opts[(Math.random() * opts.length) | 0];
    p.path = [[nx, ny]];
  }
}

    const spd=p.speed*dt;
    if(p.path && p.path.length){
      const tx=p.path[0][0], ty=p.path[0][1];
      const targetX=tx+0.5, targetY=ty+0.5;
      const dx=targetX-p.x, dy=targetY-p.y, len=Math.hypot(dx,dy)||1;
      p.x += (dx/len)*spd; p.y += (dy/len)*spd; p.dir=[Math.sign(dx), Math.sign(dy)];
      if(Math.abs(p.x-targetX)<0.05 && Math.abs(p.y-targetY)<0.05){ p.x=targetX; p.y=targetY; p.path.shift(); }
    }
    parasiteHitPlayers(p);
  });

  // Particules
  for(let i=Game.particles.length-1;i>=0;i--){
    const pa=Game.particles[i];
    if(pa.type==='cloud'){ pa.r+=2*dt; pa.life-=1*dt; if(pa.life<=0) Game.particles.splice(i,1); }
  }

// Vortex blocks timers
for(let i=Game.vortexBlocks.length-1;i>=0;i--){
  Game.vortexBlocks[i].timer -= 1*dt;
  if(Game.vortexBlocks[i].timer<=0) Game.vortexBlocks.splice(i,1);
}

// Fin de niveau / match
if (Game.remaining <= 0) {
  sfxWin();
  if (Game.mode === 'duo') {
    const p1Alive = Game.lives1 >= 0;
    const p2Alive = Game.lives2 >= 0;

    // Les deux vivants -> gagnant au score
    if (p1Alive && p2Alive) {
      if (Game.score1 > Game.score2) { endMatch('Fin — J1 gagne au score !'); return; }
      if (Game.score2 > Game.score1) { endMatch('Fin — J2 gagne au score !'); return; }
      endMatch('Fin — Égalité parfaite !'); return;
    }

    // Si l’un est déjà mort, le "dernier vivant" a déjà été géré dans playerHit()
    endMatch('Fin — Partie terminée');
    return;
  }

  // SOLO : une seule carte -> fin simple
  endMatch('Victoire !');
  return;
}

}

function parasiteHitPlayers(p){
  const hitP1 = distance(p.x,p.y, Game.p1.x,Game.p1.y) < 0.6;
  if(hitP1) playerHit(Game.p1, p); // on passe le parasite percuteur
  if(Game.mode==='duo' && Game.p2){
    const hitP2 = distance(p.x,p.y, Game.p2.x,Game.p2.y) < 0.6;
    if(hitP2) playerHit(Game.p2, p);
  }
}


function playerHit(pl, hitter){
  // --- GIROLLE (cibarius) : invulnérable pendant la chasse et 1s après conversion ---
  if (pl.species.id === 'cibarius') {

    // 3.a Pendant la fenêtre de chasse : aucune perte de vie.
    if (pl.hunterWindow > 0) {
      // Si on percute un parasite non-serviteur -> conversion immédiate
      if (hitter && !hitter.servant) {
        releaseServant(pl.pid);
        convertToServant(hitter, pl.pid);
        pl.hunterWindow = 0;        // fin de la fenêtre de chasse
        pl.invulnTimer = 60;        // invulnérable encore 1 seconde
        (pl.pid===1?UI.power1:UI.power2).textContent='Serviteur ✓';
        sfxPower();

        // Fin de la panique déclenchée par la Girolle
        Game.girollePanic.active = false;
        Game.parasites.forEach(q => { q.fleeGirolle = 0; });
      }
      // Qu'il y ait conversion ou pas : aucune perte de vie pendant la chasse
      return;
    }

    // 3.b Après conversion : encore 1s d'invulnérabilité
    if (pl.invulnTimer > 0) {
      return; // aucune perte de vie
    }
  }

  if(pl.invisible) return;
  if(pl.hitGrace>0) return;

  // Bouclier du Cèpe : ignore 1 coup + knockback ciblé (avec domino)
  if(pl.shield){
    pl.shield=false;
    (pl.pid===1?UI.power1:UI.power2).textContent='—';
    pl.hitGrace = 45;  // ~0,75s invulnérabilité

    if(hitter){
      const target = computeKnockbackTarget(hitter, pl);
      const dir = [ (target.x - hitter.x), (target.y - hitter.y) ];
      const len = Math.hypot(dir[0],dir[1])||1;
      hitter.kbActive = true;
      hitter.kbTx = target.x;
      hitter.kbTy = target.y;
      hitter.kbSpeed = pl.speed * 2;   // 2× la vitesse du champignon
      hitter.kbDir = [dir[0]/len, dir[1]/len];
      hitter.scared = Math.max(hitter.scared, 90);
      hitter.path = []; hitter.lastSeen = null;
    } else {
      // fallback de sécurité
      repelEnemiesAround(pl, 2.2, 0.9);
    }

    sfxPower();
    return;
  }

  sfxHit();
  if(pl.pid===1){ Game.lives1--; UI.lives1.textContent=Game.lives1; }
  else { Game.lives2--; UI.lives2.textContent=Game.lives2; }

  // Victoire immédiate en duo (dernier vivant)
  if(Game.mode==='duo'){
    const p1Alive=Game.lives1>=0, p2Alive=Game.lives2>=0;
    if(!p1Alive && p2Alive){ endMatch('J2 gagne — dernier vivant !'); return; }
    if(!p2Alive && p1Alive){ endMatch('J1 gagne — dernier vivant !'); return; }
  }

  // Solo : reset complet si vies < 0
if ((pl.pid===1 ? Game.lives1 : Game.lives2) < 0) {
  // Remise à zéro des états volatils des joueurs (garantit 0s d’invisibilité Trompette)
  if (Game.p1) resetPlayerRuntimeState(Game.p1);
  if (Game.p2) resetPlayerRuntimeState(Game.p2); // (au cas où p2 existe, même en solo c’est inoffensif)

  // Nettoie l’affichage des pouvoirs
  UI.power1.textContent = '—';
  UI.power2.textContent = '—';

  // Reset score/vies/niveau SOLO
  Game.lives1 = 3;
  Game.score1 = 0;
  LEVEL_INDEX = 0;
  UI.lives1.textContent = Game.lives1;
  UI.score1.textContent = Game.score1;

  // Recharge le niveau 1 (tout est sain)
  loadLevel(LEVEL_INDEX);
  return;
}


  // Réapparition immédiate + flash 5s
  const s=findOpenTile(); pl.x=s.x+0.5; pl.y=s.y+0.5; pl.dir=[0,0];
  pl.respawnFlash = 5*60; // 5 s
  pl.invisible=false; pl.phase=false; pl.frozenTimer=0;
  // --- AJOUT : lueur 2s au respawn (sans spin)
  pl.glowTimer = Math.max(pl.glowTimer||0, 120);
}

/* Update joueur */
function updatePlayer(pl, dt){
  if(!pl) return;
  pl.anim+=dt;
  if (pl.tpGrace>0) pl.tpGrace--;
  if(pl.respawnFlash>0) pl.respawnFlash--;
  if(pl.hitGrace>0) pl.hitGrace--;
  if(pl.hunterWindow>0) pl.hunterWindow--;
  if (pl.spinTimer > 0) pl.spinTimer--;
  if (pl.glowTimer > 0) pl.glowTimer--;
  if (pl.invulnTimer > 0) pl.invulnTimer--;
  // Spin après téléport : incrémente une phase locale tant que le timer est actif
if (pl.spinTimer > 0) {
  pl.spinTimer--;
  // vitesse ~ 1.5 tours/seconde (ajuste le facteur si tu veux)
  pl.spinPhase = (pl.spinPhase || 0) + 0.25 * dt; 
} else {
  // remet à zéro quand le spin est fini (évite une rotation résiduelle)
  pl.spinPhase = 0;
}

  if (pl.species.id==='cibarius' && pl.hunterWindow===0 && Game.girollePanic.active && Game.girollePanic.ownerPid===pl.pid) {
  Game.girollePanic.active = false;
  Game.parasites.forEach(q => { q.fleeGirolle = 0; });
}
 if(pl.powerTimer>0){
  pl.powerTimer--;
  if(pl.powerTimer<=0){
    // extinction de l'effet quel que soit le champignon
    pl.invisible=false; pl.speedBoost=1; pl.shield=false; pl.phase=false;
    pl.girolleTrapImmune=false; pl.trumpetTrapImmune=false;
    (pl.pid===1?UI.power1:UI.power2).textContent='—';

    // ← AJOUT : Trompette -> cooldown 10s une fois visible
    if (pl.species.id==='cornucopioides') {
      pl.trumpetCd = 600; // 10 s
    }
  }
}
// décrémenter le cooldown Trompette s'il existe
if (pl.trumpetCd>0) pl.trumpetCd--;

  if (pl.phaseCooldown>0) pl.phaseCooldown--;
  const want=inputDirFor(pl.pid); if(want[0]||want[1]) pl.nextDir=want.slice(0);
  const tx=Math.floor(pl.x), ty=Math.floor(pl.y); const cx=tx+0.5, cy=ty+0.5; const TURN_EPS=0.45;
  if(pl.frozenTimer>0){ pl.frozenTimer--; pl.dir=[0,0]; }
  else {
    if((pl.nextDir[0]||pl.nextDir[1])){
      const nearAxis = pl.nextDir[0]!==0 ? Math.abs(pl.y-cy)<TURN_EPS : Math.abs(pl.x-cx)<TURN_EPS;
      if(nearAxis && openTile(tx+pl.nextDir[0], ty+pl.nextDir[1], pl)){ if(pl.nextDir[0]!==0) pl.y=cy; else pl.x=cx; pl.dir=pl.nextDir.slice(0); }
    }
// Vitesse de base
let spdMul = (pl.speedBoost || 1);

// +30% pour la Girolle UNIQUEMENT en difficile "Guerre des Spores"
// ET UNIQUEMENT pendant la fenêtre de chasse (avant conversion)
if (pl.species.id === 'cibarius' && SelectedDifficulty.id === 'hard' && pl.hunterWindow > 0) {
  spdMul *= 1.3;
}

const spd = pl.speed * spdMul * dt;
    if(pl.dir[0]!==0){
      const sign=pl.dir[0]; let toX=pl.x+sign*spd;
      const fromTileX=Math.floor(pl.x); const toTileX=Math.floor(toX);
      if(toTileX!==fromTileX){ const ahead=fromTileX+(sign>0?1:-1); if(openTile(ahead,ty,pl)) { pl.x=toX; } else { pl.x=fromTileX+0.5; pl.dir=[0,0]; } } else { pl.x=toX; }
      pl.y += clamp(cy-pl.y,-0.3,0.3)*0.6;
    }
    if(pl.dir[1]!==0){
      const sign=pl.dir[1]; let toY=pl.y+sign*spd;
      const fromTileY=Math.floor(pl.y); const toTileY=Math.floor(toY);
      if(toTileY!==fromTileY){ const ahead=fromTileY+(sign>0?1:-1); if(openTile(tx,ahead,pl)) { pl.y=toY; } else { pl.y=fromTileY+0.5; pl.dir=[0,0]; } } else { pl.y=toY; }
      pl.x += clamp(cx-pl.x,-0.3,0.3)*0.6;
    }
  }

  // spores
  const ntX=Math.floor(pl.x), ntY=Math.floor(pl.y);

// --- VORTEX : téléportation joueur ---
if (Game.grid[ntY] && Game.grid[ntY][ntX] === VORTEX && !isVortexBlocked(ntX, ntY)) {
  if (pl.tpGrace<=0) {
    teleportEntityToOtherVortex(pl, ntX, ntY);
    sfxPower(); // petit son optionnel
  }
}

  // === Phalloïde : fin automatique après traversée d'UN mur ===
if (pl.species.id==='phalloides' && pl.phase) {
  const isWall = !!(Game.grid[ntY] && Game.grid[ntY][ntX]===1);

  if (!pl.phaseInsideWall && isWall) {
    // vient d'entrer dans un mur
    pl.phaseInsideWall = true;
  } else if (pl.phaseInsideWall && !isWall) {
    // vient de sortir d'un mur -> couper le pouvoir + cooldown 5s
    pl.phase = false;
    pl.powerTimer = 0;
    pl.phaseInsideWall = false;
    pl.phaseCooldown = 300; // 5s
    (pl.pid===1?UI.power1:UI.power2).textContent='—';
  }
}

  if(Game.grid[ntY] && Game.grid[ntY][ntX]===2){
    Game.grid[ntY][ntX]=0; Game.remaining--; sfxEat(); refreshPelletCell(ntX,ntY);
      // ← AJOUT : compteur de spores pour la durée du pouvoir Trompette
  pl.collectedSpores = (pl.collectedSpores||0) + 1;
    
    if(pl.pid===1){ Game.score1+=10; UI.score1.textContent=Game.score1; } else { Game.score2+=10; UI.score2.textContent=Game.score2; }
    pdateLeaderHUD();
  }
  
  // bonus
  for(let i=Game.bonuses.length-1;i>=0;i--){
    const b=Game.bonuses[i];
    if(b.x===ntX && b.y===ntY){ eatBonusFor(pl,b); Game.bonuses.splice(i,1); }
  }

  // pièges
  if(Game.grid[ntY] && Game.grid[ntY][ntX]===4){
    const idx=Game.traps.findIndex(t=>t.x===ntX && t.y===ntY);
    if(idx>=0){
      const trap=Game.traps[idx]; Game.traps.splice(idx,1); Game.grid[ntY][ntX]=0;
      if(!(pl.species.id==='cornucopioides' && pl.trumpetTrapImmune)){
        if(trap.t===0){ spawnEnemy(); } else { pl.frozenTimer=5*60; }
      }
    }
  }
}

/* Rendu */
function draw(){
  if(!Game.themeLayer||!Game.wallsLayer){
    const g=CTX.createLinearGradient(0,0,0,H); g.addColorStop(0,'#1a1620'); g.addColorStop(1,'#0d0a12'); CTX.fillStyle=g; CTX.fillRect(0,0,W,H); return;
  }
  CTX.drawImage(Game.themeLayer,0,0);
  CTX.drawImage(Game.pelletsLayer,0,0);
  drawTrapsAndBonuses();
  CTX.drawImage(Game.wallsLayer,0,0);

  Game.particles.forEach(pa=>{
    if(pa.type==='cloud'){ CTX.globalAlpha=0.2; CTX.beginPath(); CTX.arc(pa.x,pa.y,pa.r,0,6.28); CTX.fillStyle='#ffffff'; CTX.fill(); CTX.globalAlpha=1; }
  });

  Game.parasites.forEach(p=>{
    drawParasite(CTX,p.x*TILE,p.y*TILE,TILE*0.9,p.kind,p.servant,(p.blind>0),(p.confusedTimer>0));
    if(p.scared>0){ CTX.globalAlpha=0.4; CTX.fillStyle='#fff'; CTX.fillRect(p.x*TILE-10,p.y*TILE-10,20,20); CTX.globalAlpha=1; }
    if(p.kbActive){
      // petite traînée
      CTX.save(); CTX.globalAlpha=0.15;
      CTX.fillStyle='#ffe6aa'; CTX.beginPath();
      CTX.arc(p.x*TILE, p.y*TILE, 8, 0, Math.PI*2); CTX.fill();
      CTX.restore();
    }
    if (p.frozen > 0) {
  CTX.save();
  CTX.globalAlpha = 0.35;
  CTX.fillStyle = '#9ad6ff';
  CTX.beginPath();
  CTX.arc(p.x*TILE, p.y*TILE, 12, 0, Math.PI*2);
  CTX.fill();
  CTX.restore();
}
  });

  if(Game.p1) drawPlayerEntity(Game.p1);
  if(Game.mode==='duo' && Game.p2) drawPlayerEntity(Game.p2);

  // Indication de départ
  if(Game.showStartHint>0){
    Game.showStartHint--;
    CTX.save();
    CTX.globalAlpha = 0.85*(Math.sin(performance.now()/250)*0.5+0.5);
    CTX.fillStyle='#00000088'; CTX.fillRect(W*0.25,H*0.42,W*0.5,80);
    CTX.globalAlpha=1;
    CTX.fillStyle='#fff'; CTX.font='bold 26px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle';
    CTX.fillText('Appuyez sur P pour lancer la partie', W/2, H*0.5);
    CTX.restore();
  }

  // État pause / compte à rebours
  if(Game.paused && Game.countdown===0){
    CTX.save(); CTX.globalAlpha=0.35; CTX.fillStyle='#000'; CTX.fillRect(0,0,W,H);
    CTX.globalAlpha=1; CTX.fillStyle='#fff'; CTX.font='bold 42px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle';
    CTX.fillText('PAUSE — P pour lancer', W/2, H*0.5); CTX.restore();
  } else if(Game.countdown>0){
    const sec=Math.ceil(Game.countdown/60);
    CTX.save(); CTX.globalAlpha=0.3; CTX.fillStyle='#000'; CTX.fillRect(0,0,W,H); CTX.globalAlpha=1;
    CTX.fillStyle='#fff'; CTX.font='bold 120px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle';
    CTX.fillText(sec.toString(), W/2, H*0.5); CTX.restore();
  }
}

function drawTrapsAndBonuses(){
  Game.traps.forEach(t=>{
    const px=t.x*TILE+TILE/2,py=t.y*TILE+TILE/2;
    CTX.save();
    if(t.t===0){ CTX.beginPath(); CTX.moveTo(px,py-8); CTX.lineTo(px-8,py+8); CTX.lineTo(px+8,py+8); CTX.closePath(); CTX.fillStyle='#a83b3b'; CTX.fill(); }
    else { CTX.beginPath(); CTX.ellipse(px,py,10,6,0,0,6.28); CTX.fillStyle='#7fbf7f88'; CTX.fill(); }
    CTX.restore();
  });
  if(Game.muscariaTrap1 && Game.muscariaTrap1.active){
    const px=Game.muscariaTrap1.x*TILE+TILE/2, py=Game.muscariaTrap1.y*TILE+TILE/2;
    CTX.save(); CTX.beginPath(); CTX.arc(px,py,13,0,Math.PI*2); CTX.fillStyle='rgba(255,64,128,0.18)'; CTX.fill();
    CTX.lineWidth=3; CTX.strokeStyle='#ff3b7a'; CTX.stroke(); CTX.font='bold 12px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle='#ffd6e6'; CTX.fillText('π1',px,py); CTX.restore();
  }
  if(Game.muscariaTrap2 && Game.muscariaTrap2.active){
    const px=Game.muscariaTrap2.x*TILE+TILE/2, py=Game.muscariaTrap2.y*TILE+TILE/2;
    CTX.save(); CTX.beginPath(); CTX.arc(px,py,13,0,Math.PI*2); CTX.fillStyle='rgba(64,128,255,0.18)'; CTX.fill();
    CTX.lineWidth=3; CTX.strokeStyle='#3b7aff'; CTX.stroke(); CTX.font='bold 12px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle='#d6e0ff'; CTX.fillText('π2',px,py); CTX.restore();
  }
  Game.bonuses.forEach(b=>{
    const px=b.x*TILE+TILE/2,py=b.y*TILE+TILE/2;
    CTX.save();
    let col='#fff',label='?';
    if(b.kind==='life'){col='#ff5c6c';label='❤';}
    if(b.kind==='speed'){col='#ffe066';label='⚡';}
    if(b.kind==='power'){col='#9ad6ff';label='★';}
    if(b.kind==='score'){col='#a1ffa4';label='⨁';}
    if(b.kind==='freeze'){col='#d8c7ff';label='❄';}
    CTX.beginPath(); CTX.arc(px,py,10,0,6.28); CTX.fillStyle=col+'33'; CTX.fill(); CTX.strokeStyle=col; CTX.lineWidth=2; CTX.stroke();
    CTX.font='16px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillStyle=col; CTX.fillText(label,px,py+1);
    CTX.restore();
  });
// --- VORTEX 🌀 (rotation continue de l’emoji) ---
Game.vortexes.forEach(v=>{
  const px = v.x*TILE + TILE/2;
  const py = v.y*TILE + TILE/2;

  // vitesse de rotation (~0.003 rad/ms -> ~1 tour toutes ~2s)
  const angle = performance.now() * 0.003;

  CTX.save();

  // anneau externe (fixe)
  CTX.beginPath();
  CTX.arc(px, py, 14, 0, Math.PI*2);
  CTX.fillStyle = 'rgba(150,200,255,0.12)';
  CTX.fill();
  CTX.lineWidth = 2;
  CTX.strokeStyle = 'rgba(150,200,255,0.55)';
  CTX.stroke();

  // cœur (fixe)
  CTX.beginPath();
  CTX.arc(px, py, 8, 0, Math.PI*2);
  CTX.fillStyle = 'rgba(90,140,255,0.35)';
  CTX.fill();

  // emoji en rotation
  CTX.translate(px, py);
  CTX.rotate(angle);
  CTX.font = '16px system-ui';
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  CTX.fillStyle = '#e8f0ff';
  CTX.fillText('🌀', 0, 1);

  CTX.restore();
});
}

function drawPlayerEntity(pl){
  const x = pl.x * TILE, y = pl.y * TILE;

  // --- GLOW luciole (respawn / départ / téléport) ---
  if(pl.glowTimer > 0){
    const t = performance.now() / 200;
    const base = 0.6 + 0.4 * Math.sin(t * 2*Math.PI);  // pulsation
    const fade = pl.glowTimer / 120;                   // décroissance
    const intensity = base * fade;

    const r = 28 + 10 * Math.sin(t * 1.3);
    const g = CTX.createRadialGradient(x, y, r*0.25, x, y, r);
    g.addColorStop(0, `rgba(255,240,180,${0.65*intensity})`);
    g.addColorStop(0.4, `rgba(255,220,120,${0.25*intensity})`);
    g.addColorStop(1, 'rgba(255,220,120,0)');

    CTX.save();
    CTX.globalCompositeOperation = "screen";
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(x, y, r, 0, Math.PI*2);
    CTX.fill();
    CTX.restore();
  }

  // --- Fonction de rendu champignon (sprite centré) ---
  const drawMushroomCentered = (cx, cy) => {
    if(pl.species.id==='cornucopioides')      drawTrumpet(CTX, cx, cy, 28, false, (pl.powerTimer>0));
    else if(pl.species.id==='muscaria')       drawAmanita(CTX, cx, cy, 28, false);
    else if(pl.species.id==='cibarius')       drawChanterelle(CTX, cx, cy, 28, false);
    else if(pl.species.id==='edulis')         drawCep(CTX, cx, cy, 28, false);
    else if(pl.species.id==='morchella')      drawMorel(CTX, cx, cy, 28, false);
    else if(pl.species.id==='phalloides')     drawPhalloides(CTX, cx, cy, 28, false);
  };

  // --- SPIN après téléportation ---
  if (pl.spinTimer > 0){
    const angle = performance.now() / 300; // rotation fluide
    CTX.save();
    CTX.translate(x, y);
    CTX.rotate(angle);
    drawMushroomCentered(0, 0); // champignon tournant
    CTX.restore();
  } else {
    drawMushroomCentered(x, y); // affichage normal
  }

  // --- Effets supplémentaires ---
  if(pl.frozenTimer > 0){
    CTX.save(); CTX.globalAlpha=0.35; CTX.fillStyle='#9ad6ff';
    CTX.beginPath(); CTX.arc(x, y, 16, 0, Math.PI*2); CTX.fill(); CTX.restore();
  }

if (pl.powerTimer > 0) {
  if (pl.species.id === 'cornucopioides' && pl.invisible) {
    // --- Halo noir encre, moins opaque, placé DERRIÈRE le sprite ---
    const t = performance.now();
    const baseR = 22;
    const pulse = 4 * Math.sin(t / 180);
    const R = baseR + pulse;

    // Dégradé radial plus léger : silhouette visible
    const g = CTX.createRadialGradient(x, y, R * 0.15, x, y, R * 1.25);
    g.addColorStop(0.00, 'rgba(0,0,0,0.58)');
    g.addColorStop(0.50, 'rgba(0,0,0,0.42)');
    g.addColorStop(1.00, 'rgba(0,0,0,0.00)');

    CTX.save();
    // place le halo derrière ce qui est déjà dessiné (la Trompette)
    CTX.globalCompositeOperation = 'destination-over';
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(x, y, R * 1.15, 0, Math.PI * 2);
    CTX.fill();

    // petites nappes/taches discrètes
    for (let i = 0; i < 4; i++) {
      const ang = (t / 520) + i * (Math.PI / 2);
      const ox = Math.cos(ang) * 6;
      const oy = Math.sin(ang) * 4;
      const r2 = R * 0.5;
      const g2 = CTX.createRadialGradient(x+ox, y+oy, r2 * 0.1, x+ox, y+oy, r2);
      g2.addColorStop(0.00, 'rgba(0,0,0,0.48)');
      g2.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      CTX.beginPath();
      CTX.fillStyle = g2;
      CTX.arc(x + ox, y + oy, r2, 0, Math.PI * 2);
      CTX.fill();
    }
    CTX.restore();

    // Compte à rebours (secondes) — minuscule blanc
    const secs = Math.max(0, Math.ceil(pl.powerTimer / 60));
    CTX.save();
    CTX.font = '10px system-ui';
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.lineWidth = 3;
    CTX.strokeStyle = 'rgba(0,0,0,0.85)';
    CTX.strokeText(String(secs), x, y);
    CTX.fillStyle = '#ffffff';
    CTX.fillText(String(secs), x, y);
    CTX.restore();
  } else {
    // autres pouvoirs : garde ton effet existant OU mets rien si tu ne veux plus de cercle
    const r = 12 + (Math.sin(performance.now() / 120) + 1) * 6;
    CTX.beginPath(); CTX.arc(x, y, r, 0, Math.PI * 2);
    CTX.lineWidth = 2; CTX.strokeStyle = 'rgba(255,255,255,0.55)'; CTX.stroke();
  }
}


  if(pl.respawnFlash > 0){
    const t=performance.now()/120;
    const blink = (Math.floor(t)%2===0) ? 0.85 : 0.35;
    const r=22 + 6*Math.sin(performance.now()/180);
    CTX.save();
    CTX.globalAlpha = blink;
    CTX.beginPath(); CTX.arc(x,y,r,0,Math.PI*2);
    CTX.lineWidth=4; CTX.strokeStyle = 'rgba(255,255,180,0.95)';
    CTX.stroke();
    CTX.restore();
  }

  if(pl.species.id==='edulis' && pl.hitGrace > 0){
    const t = (45 - pl.hitGrace) / 45;
    const r = 12 + t * 14;
    CTX.save();
    CTX.globalAlpha = 0.35*(1 - t);
    CTX.beginPath();
    CTX.arc(x, y, r, 0, Math.PI*2);
    CTX.lineWidth = 3;
    CTX.strokeStyle = 'rgba(255,230,160,0.9)';
    CTX.stroke();
    CTX.restore();
  }
}


/* Fin de match */
function endMatch(message){
  Game.paused=true; Game.countdown=0;
  const ov=document.createElement('div'); ov.className='ov'; const card=document.createElement('div'); card.className='card'; ov.appendChild(card);
  const t=document.createElement('div'); t.className='title'; t.textContent=message; card.appendChild(t);
  const sub=document.createElement('div'); sub.className='sub';
  sub.textContent=`Scores — J1: ${Game.score1} · J2: ${Game.score2}`;
  card.appendChild(sub);
  const btn=document.createElement('button'); btn.className='btn'; btn.textContent='Rejouer'; btn.addEventListener('click', ()=>{ ov.remove(); openOverlay(); });
  card.appendChild(btn);
  document.body.appendChild(ov);
}

/* Auto tests + Init */
(function selfTests(){ try{
  console.assert(COLS>0&&ROWS>0,'grid dims');
  const m=genLevel(12345);
  console.assert(isGridShape(m,COLS,ROWS),'maze dims');
  const pellets=m.flat().filter(v=>v===2).length; console.assert(pellets>COLS,'pellets enough');
  console.assert(typeof findNearestPellet==='function','nearest pellet helper');
} catch(e){ console.error('Self-tests failed',e); }})();

function init(){ createOverlay(); loop(); }
if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }

/* =================== FIN =================== */
</script>
</body>
</html>
